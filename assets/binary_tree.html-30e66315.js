import{_ as e,r as o,o as c,c as l,a as n,b as s,d as p,e as a}from"./app-aa9cafec.js";const i="/MLblogs/assets/2024-02-22-23-39-26-image-e7770284.png",u="/MLblogs/assets/2024-02-26-21-21-57-image-3c4af9c2.png",r="/MLblogs/assets/2024-03-01-10-16-38-image-28a14466.png",k="/MLblogs/assets/2024-03-01-10-33-23-image-3489c9dd.png",d="/MLblogs/assets/2024-03-04-16-34-16-image-61a4c4e0.png",v="/MLblogs/assets/2024-03-05-10-11-32-image-9829d429.png",m="/MLblogs/assets/2024-03-06-10-16-28-image-cb39e933.png",b={},h=n("h2",{id:"理论基础",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#理论基础","aria-hidden":"true"},"#"),s(" 理论基础")],-1),y={href:"https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"},g=n("p",null,[n("strong",null,"满二叉树"),s("：树中只有度为0和度为2的节点。深度为k，有"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"k")]),n("mo",null,"−"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"2^k-1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8491em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])])])])])]),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])]),s("个节点的二叉树")],-1),f=n("p",null,[n("strong",null,"完全二叉树"),s("：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mo",{stretchy:"false"},"["),n("mn",null,"1"),n("mo",{separator:"true"},","),n("msup",null,[n("mn",null,"2"),n("mrow",null,[n("mo",{stretchy:"false"},"("),n("mi",null,"h"),n("mo",null,"−"),n("mn",null,"1"),n("mo",{stretchy:"false"},")")])]),n("mo",{stretchy:"false"},"]")]),n("annotation",{encoding:"application/x-tex"},"[1,2^{(h-1)}]")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.138em","vertical-align":"-0.25em"}}),n("span",{class:"mopen"},"["),n("span",{class:"mord"},"1"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.888em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mopen mtight"},"("),n("span",{class:"mord mathnormal mtight"},"h"),n("span",{class:"mbin mtight"},"−"),n("span",{class:"mord mtight"},"1"),n("span",{class:"mclose mtight"},")")])])])])])])])]),n("span",{class:"mclose"},"]")])])]),s("个节点。"),n("strong",null,"优先级队列其实是一个堆，堆就是一棵完全二叉树")],-1),w=a('<img src="'+i+'" title="" alt="" data-align="center"><p><strong>二叉搜索树</strong>：是一个有序树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li></ul><p><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树。是一棵空树或它的左右两个子树的高度差的绝对值不超过1。<strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p><h2 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历" aria-hidden="true">#</a> 前序遍历</h2>',5),_={href:"https://leetcode.cn/problems/binary-tree-preorder-traversal/",target:"_blank",rel:"noopener noreferrer"},x=n("p",null,"难度：简单",-1),q=n("p",null,[n("strong",null,"方法1：递归")],-1),N=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),O=n("p",null,[s("空间复杂度：平均情况："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logn)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("，最坏的情况："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("。不计ans列表")],-1),T=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">digui</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者按照如下的写法更加简洁：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        left <span class="token operator">=</span> self<span class="token punctuation">.</span>preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        <span class="token keyword">return</span>  <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+</span> left <span class="token operator">+</span>  right
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代</strong></p>`,4),S=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),L=a(`<p>空间复杂度：平均情况：O(logn)，最坏的情况：O(n)。不计ans列表</p><p>用栈实现，先压入一个Node 的右节点，然后压入左节点，使得左节点在栈顶。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span> 
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>前序遍历的迭代代码最简单，其次是中序，后续遍历需要额外的prev变量</strong>。</p><p>为了让三种遍历的迭代代码更加统一，这里用另一种方法来写：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node<span class="token punctuation">,</span> visited <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> visited<span class="token punctuation">:</span>
                <span class="token comment"># 下面是后序：若是其他顺序遍历，只需修改下面三行的顺序</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="后续遍历" tabindex="-1"><a class="header-anchor" href="#后续遍历" aria-hidden="true">#</a> 后续遍历</h2>`,7),M={href:"https://leetcode.cn/problems/binary-tree-postorder-traversal/",target:"_blank",rel:"noopener noreferrer"},z=a(`<p>难度：简单</p><p><strong>方法1：递归</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">digui</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> 
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        self<span class="token punctuation">.</span>ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代</strong></p><p>后续遍历很容易将遍历过的节点重复加入栈，所以需要标记一下。这里使用Prev来表示前一个遍历过的节点。</p><p>何时将当前节点的值访问？</p><ol><li><p>当其左右子节点都为空时，可以直接访问</p></li><li><p>当其左右子节点有被访问过的时，直接访问（这里可能疑惑，若访问了left，后续遍历应该接下来访问的是right，这里不应该是当左右节点都被访问了才轮得到判断是否访问current嘛，换而言之，当left被访问了，此时应该判断是否访问right，而不是current----解释：因为入栈的顺序是：root, right, left，所以既然栈顶元素是current，就证明：若其左右都不为空或者left=None，则上一个被访问的一定是right，若right=None，则上一个访问的是left，所以不用像上面说的那样，判断是否要先访问right，再访问current。)</p></li></ol><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        prev <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            current <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token comment"># 何时将current值访问？</span>
            <span class="token comment"># 1. 其左右节点为空；2. 其子节点被访问过</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> current<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> current<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>prev <span class="token keyword">and</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> current<span class="token punctuation">.</span>left <span class="token keyword">or</span> prev <span class="token operator">==</span> current<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                prev <span class="token operator">=</span> current
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> current<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                <span class="token keyword">if</span> current<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>另一种写法</strong>：</p><p>这种写法和中序遍历的迭代代码的结构更像。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        res <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        prev <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token keyword">while</span> root <span class="token keyword">or</span> stack<span class="token punctuation">:</span>
            <span class="token keyword">while</span> root<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 若右节点为空或者已经被访问过，则可以访问当前节点</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right <span class="token keyword">or</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> prev<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                prev <span class="token operator">=</span> root
                root <span class="token operator">=</span> <span class="token boolean">None</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># 若右节点不为空，将当前节点入栈，再切换到右子树上</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right

        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h2><p>题目：</p><p>难度：简答</p><p><strong>方法1：递归</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">digui</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> 
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        self<span class="token punctuation">.</span>ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> stack <span class="token keyword">or</span> root<span class="token punctuation">:</span>
            <span class="token keyword">while</span> root<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="层序遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历" aria-hidden="true">#</a> 层序遍历</h2><h3 id="_102-二叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#_102-二叉树的层序遍历" aria-hidden="true">#</a> 102. 二叉树的层序遍历</h3>`,20),F={href:"https://leetcode.cn/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},B=a(`<p>难度：中等</p><p><strong>方法1：队列</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            layer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                layer<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_107-二叉树的层序遍历2" tabindex="-1"><a class="header-anchor" href="#_107-二叉树的层序遍历2" aria-hidden="true">#</a> 107. 二叉树的层序遍历2</h3>`,6),V={href:"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/",target:"_blank",rel:"noopener noreferrer"},D=n("p",null,"难度：中等",-1),A=n("p",null,[n("strong",null,"方法1：队列")],-1),j=n("p",null,"相对于上一题，将ans反转一下即可：",-1),P=n("p",null,[n("code",null,"ans[::-1]")],-1),C=n("h3",{id:"_199-二叉树的右视图",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_199-二叉树的右视图","aria-hidden":"true"},"#"),s(" 199. 二叉树的右视图")],-1),E={href:"https://leetcode.cn/problems/binary-tree-right-side-view/",target:"_blank",rel:"noopener noreferrer"},I=a(`<p>难度：中等</p><p><strong>方法1：队列</strong></p><p>其实还是层序遍历，将每一层的最后一个节点值加入ans</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：递归</strong></p><p>这个递归思路很巧妙，每次先加入right，利用参数depth来判断是否是新的一层中第一个访问到的节点。若是，则肯定是那一层中最右边的。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>
        <span class="token comment"># 先访问 当前节点，再递归地访问 右子树 和 左子树。</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>ans<span class="token punctuation">)</span> <span class="token operator">==</span> depth<span class="token punctuation">:</span>
            <span class="token comment"># 如果当前节点所在深度还没有出现在res里，</span>
            <span class="token comment"># 说明在该深度下当前节点是第一个被访问的节点，</span>
            <span class="token comment"># 因此将当前节点加入res中。</span>
            self<span class="token punctuation">.</span>ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        depth <span class="token operator">+=</span> <span class="token number">1</span>
        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 从根节点开始访问，根节点深度是0</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_637-二叉树的层平均值" tabindex="-1"><a class="header-anchor" href="#_637-二叉树的层平均值" aria-hidden="true">#</a> 637. 二叉树的层平均值</h3>`,10),R={href:"https://leetcode.cn/problems/average-of-levels-in-binary-tree/",target:"_blank",rel:"noopener noreferrer"},K=a(`<p>难度：简单</p><p><strong>方法1：队列</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            mean <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                mean <span class="token operator">+=</span> node<span class="token punctuation">.</span>val
            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>mean <span class="token operator">/</span> sz<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：dfs</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>
            <span class="token keyword">if</span> level <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 若是当前层，则level应该比len(ans)小1，因为从0开始</span>
                ans<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">+=</span> root<span class="token punctuation">.</span>val
                count<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 到了新的下一层</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                count<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span>s <span class="token operator">/</span> n <span class="token keyword">for</span> s<span class="token punctuation">,</span> n <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_429-n-叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#_429-n-叉树的层序遍历" aria-hidden="true">#</a> 429. N 叉树的层序遍历</h3>`,6),G={href:"https://leetcode.cn/problems/n-ary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},H=a(`<p>难度：中等</p><p><strong>方法1：队列</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>

        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            layer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                layer<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token keyword">for</span> child <span class="token keyword">in</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>child<span class="token punctuation">)</span>

            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：递归</strong></p><p>从这些题中发现，层序遍历如果要用递归来完成，就需要记录深度。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> 
            <span class="token keyword">if</span> depth <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>child<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>

        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_515-在每个树行中找最大值" tabindex="-1"><a class="header-anchor" href="#_515-在每个树行中找最大值" aria-hidden="true">#</a> 515. 在每个树行中找最大值</h3>`,7),J={href:"https://leetcode.cn/problems/find-largest-value-in-each-tree-row/",target:"_blank",rel:"noopener noreferrer"},Q=a(`<p>难度：中等</p><p><strong>方法1：队列</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">largestValues</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            max_val <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                max_val <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>max_val<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>max_val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：dfs</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">largestValues</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> 
            <span class="token keyword">if</span> depth <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_116-填充每个节点的下一个右侧节点指针" tabindex="-1"><a class="header-anchor" href="#_116-填充每个节点的下一个右侧节点指针" aria-hidden="true">#</a> 116. 填充每个节点的下一个右侧节点指针</h3>`,6),U={href:"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/",target:"_blank",rel:"noopener noreferrer"},W=a(`<p>难度：中等</p><p><strong>方法1：队列</strong></p><p>其实就是在层序遍历的代码中做一点修改</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Optional[Node]&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;Optional[Node]&#39;</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> root
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            prev <span class="token operator">=</span> <span class="token boolean">None</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> prev<span class="token punctuation">:</span>
                    prev<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node
                prev <span class="token operator">=</span> node
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_117-填充每个节点的下一个右侧节点指针2" tabindex="-1"><a class="header-anchor" href="#_117-填充每个节点的下一个右侧节点指针2" aria-hidden="true">#</a> 117. 填充每个节点的下一个右侧节点指针2</h3>`,5),X={href:"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/",target:"_blank",rel:"noopener noreferrer"},Y=n("p",null,"难度：中等",-1),Z=n("p",null,[s("上一题说的是满二叉树，本题没有这个限制，但是用上题代码就可以通过。但是空间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),$=n("p",null,[n("strong",null,"方法1：虚拟头节点")],-1),nn=n("p",null,[s("使用空间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])]),s("实现：思路是，遍历当前层的时候，可以将下一层的节点都连接起来。")],-1),sn=a(`<p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Optional[Node]&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;Optional[Node]&#39;</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> root
        cur <span class="token operator">=</span> root
        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>
            dummy <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 下一层的起始节点的虚拟头结点</span>
            p <span class="token operator">=</span> dummy
            <span class="token keyword">while</span> cur<span class="token punctuation">:</span>
                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur<span class="token punctuation">.</span>left
                    p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>
                <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur<span class="token punctuation">.</span>right
                    p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>
                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
            cur <span class="token operator">=</span> dummy<span class="token punctuation">.</span><span class="token builtin">next</span>

        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：dfs</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">connect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">:</span>
        pre <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">,</span> depth<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            <span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># node 是这一层最左边的节点</span>
                pre<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># pre[depth] 是 node 左边的节点</span>
                pre<span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node  <span class="token comment"># node 左边的节点指向 node</span>
                pre<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> node
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 根节点的深度为 0</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_104-二叉树的最大深度" tabindex="-1"><a class="header-anchor" href="#_104-二叉树的最大深度" aria-hidden="true">#</a> 104. 二叉树的最大深度</h3>`,8),an={href:"https://leetcode.cn/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},tn=a(`<p>难度：简单</p><p><strong>方法1：队列</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            ans <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：递归</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> 
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            left_height <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right_height <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_height<span class="token punctuation">,</span> right_height<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法3：dfs</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> 
                <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>layers<span class="token punctuation">)</span> <span class="token operator">==</span> depth<span class="token punctuation">:</span>
                layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        layers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span>  <span class="token builtin">len</span><span class="token punctuation">(</span>layers<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_111-二叉树的最小深度" tabindex="-1"><a class="header-anchor" href="#_111-二叉树的最小深度" aria-hidden="true">#</a> 111. 二叉树的最小深度</h3>`,8),pn={href:"https://leetcode.cn/problems/minimum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},en=a(`<p>难度：简单</p><p><strong>方法1：队列</strong></p><p>一层一层遍历，碰到某一个点的左右子节点都为空，则返回当前的高度</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            ans <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                    <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：递归</strong></p><p>最小高度不能直接套用最大高度的代码，因为有一个特殊情况无法正确解决，即：</p><img title="" src="`+u+`" alt="" width="75" data-align="center"><p>要单独拿出来作为一个新的情况来讨论。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> root<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> 
            <span class="token comment"># 有一个为空的情况很特殊，如果直接返回:</span>
            <span class="token comment"># min(left_depth, right_depth)+1，则结果永远都是1</span>
            <span class="token comment"># 比如特殊情况：depth = n, n为节点个数</span>
            <span class="token comment"># 如果按上述返回，则结果是1，显然不对</span>
            <span class="token comment"># 所以要将这一特殊情况拿出来单独讨论</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            left_depth <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right_depth <span class="token operator">=</span> self<span class="token punctuation">.</span>minDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>left_depth<span class="token punctuation">,</span> right_depth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_226-翻转二叉树" tabindex="-1"><a class="header-anchor" href="#_226-翻转二叉树" aria-hidden="true">#</a> 226. 翻转二叉树</h2>`,10),on={href:"https://leetcode.cn/problems/invert-binary-tree/",target:"_blank",rel:"noopener noreferrer"},cn=a(`<p>难度：简单</p><p><strong>方法1：递归</strong></p><p>每一个子树的左右互换一下。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> root
        root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left
        self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>invertTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：栈</strong></p><p>同一层的节点不会互相影响，每一个节点只负责将其左右子节点互换即可，所以使用栈还是队列实现都可以。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> root
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token operator">=</span>  node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_101-对称二叉树" tabindex="-1"><a class="header-anchor" href="#_101-对称二叉树" aria-hidden="true">#</a> 101. 对称二叉树</h2>`,8),ln={href:"https://leetcode.cn/problems/symmetric-tree/",target:"_blank",rel:"noopener noreferrer"},un=a(`<p>难度：简单</p><p><strong>方法1：递归</strong></p><p>递归不一定只能传入一个参数，还可以传入两个参数！</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">digui</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">if</span> left<span class="token punctuation">.</span>val <span class="token operator">==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            res1 <span class="token operator">=</span> self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            res2 <span class="token operator">=</span> self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">return</span> res1 <span class="token keyword">and</span> res2
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>digui<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：层序遍历+回文检测</strong></p><p>层序遍历，然后每一层检测是否是回文。</p><p>时间复杂度：O(2n)。检测回文部分的时间复杂度和层的节点数有关，可以均摊到每一个节点上，所以时间复杂度为O(2n)。</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">huiwen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
        i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">while</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> seq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span> 
                i <span class="token operator">-=</span> <span class="token number">1</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>

    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            layer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                    layer<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 注意即便是空也要将空加入</span>
                    layer<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>huiwen<span class="token punctuation">(</span>layer<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法3：层序遍历，不用回文检测</strong></p><p>上面回文检测还要单独对这一层再检测一遍，多花了时间，其实还可以用两个指针，一个从这一层的左边开始，一个从右边开始，若都相等，则当前层满足要求：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            u <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            v <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> u <span class="token keyword">and</span> <span class="token keyword">not</span> v<span class="token punctuation">:</span>
                <span class="token comment"># 二者都为 None</span>
                <span class="token keyword">continue</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> u <span class="token keyword">or</span> <span class="token keyword">not</span> v <span class="token keyword">or</span> u<span class="token punctuation">.</span>val <span class="token operator">!=</span> v<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                <span class="token comment"># 只有一个为None or 二者值不等</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_100-相同的树" tabindex="-1"><a class="header-anchor" href="#_100-相同的树" aria-hidden="true">#</a> 100. 相同的树</h2>`,13),rn={href:"https://leetcode.cn/problems/same-tree/",target:"_blank",rel:"noopener noreferrer"},kn=a(`<p>难度：简单</p><p>弄懂上一题之后，本题刷起来很轻松。</p><p><strong>方法1：递归</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> p <span class="token keyword">and</span> <span class="token keyword">not</span> q<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>  <span class="token comment"># all None</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> p <span class="token keyword">or</span> <span class="token keyword">not</span> q<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>  <span class="token comment"># one None</span>
        <span class="token keyword">if</span> p<span class="token punctuation">.</span>val <span class="token operator">!=</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>isSameTree<span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> q<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">,</span> q<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            u <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            v <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> u <span class="token keyword">and</span> <span class="token keyword">not</span> v<span class="token punctuation">:</span> <span class="token keyword">continue</span> <span class="token comment"># all None</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> u <span class="token keyword">or</span> <span class="token keyword">not</span> v<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>  <span class="token comment"># one None</span>
            <span class="token keyword">if</span> u<span class="token punctuation">.</span>val <span class="token operator">!=</span> v<span class="token punctuation">.</span>val<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>  <span class="token comment"># val not equal</span>
            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">.</span>left<span class="token punctuation">)</span>

            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_572-另一棵树的子树" tabindex="-1"><a class="header-anchor" href="#_572-另一棵树的子树" aria-hidden="true">#</a> 572. 另一棵树的子树</h2>`,7),dn={href:"https://leetcode.cn/problems/subtree-of-another-tree/",target:"_blank",rel:"noopener noreferrer"},vn=n("p",null,"难度：简单",-1),mn=n("p",null,[n("strong",null,"方法1：dfs+暴力匹配")],-1),bn=n("p",null,"这是一种最朴素的方法——深度优先搜索枚举 s 中的每一个节点，判断这个点的子树是否和 t 相等。",-1),hn=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"s"),n("mo",null,"×"),n("mi",null,"t"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(s\\times t)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"s"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"×"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"t"),n("span",{class:"mclose"},")")])])]),s("，s和t分别是两棵树的节点数量")],-1),yn=n("p",null,[s("空间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"s"),n("mo",null,"+"),n("mi",null,"t"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(s+t)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"s"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"t"),n("span",{class:"mclose"},")")])])])],-1),gn=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSame</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> u <span class="token keyword">and</span> <span class="token keyword">not</span> v<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> u <span class="token keyword">or</span> <span class="token keyword">not</span> v<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            node1 <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node2 <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node1 <span class="token keyword">and</span> <span class="token keyword">not</span> node2<span class="token punctuation">:</span> <span class="token keyword">continue</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node1 <span class="token keyword">or</span> <span class="token keyword">not</span> node2<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>val <span class="token operator">==</span> node2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>

    <span class="token keyword">def</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> subRoot<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token comment"># 递归版本的前序遍历</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>isSame<span class="token punctuation">(</span>node<span class="token punctuation">,</span> subRoot<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：KMP</strong></p><p>思路：一棵子树上的点在深度优先搜索序列（即先序遍历）中是连续的。这样我们可以确定解决这个问题的方向就是：把 s 和 t 先转换成深度优先搜索序列，然后看 t 的深度优先搜索序列是否是 s 的深度优先搜索序列的「子串」。</p>`,3),fn=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"2"),n("mo",{stretchy:"false"},"("),n("mi",null,"m"),n("mo",null,"+"),n("mi",null,"n"),n("mo",{stretchy:"false"},")"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(2(m+n))")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"2"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"m"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},"))")])])]),s("，m和n分别为两个先序遍历序列的长度")],-1),wn=n("p",null,[s("空间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"m"),n("mo",null,"+"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(m+n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"m"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),_n=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> 
                nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> nums

    <span class="token keyword">def</span> <span class="token function">kmp</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> order<span class="token punctuation">,</span> sub_order<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sub_order<span class="token punctuation">)</span><span class="token punctuation">:</span> 
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token comment"># get next_</span>
        next_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sub_order<span class="token punctuation">)</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sub_order<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> i <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token keyword">and</span> sub_order<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> sub_order<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                i <span class="token operator">=</span> next_<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> sub_order<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> sub_order<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            next_<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i
        <span class="token comment"># match</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> i <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token keyword">and</span> order<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> sub_order<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                i <span class="token operator">=</span> next_<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> order<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> sub_order<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sub_order<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> subRoot<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        sub_order <span class="token operator">=</span> self<span class="token punctuation">.</span>preOrder<span class="token punctuation">(</span>subRoot<span class="token punctuation">)</span>
        order <span class="token operator">=</span> self<span class="token punctuation">.</span>preOrder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>kmp<span class="token punctuation">(</span>order<span class="token punctuation">,</span> sub_order<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_559-n-叉树的最大深度" tabindex="-1"><a class="header-anchor" href="#_559-n-叉树的最大深度" aria-hidden="true">#</a> 559. N 叉树的最大深度</h2>`,2),xn={href:"https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/",target:"_blank",rel:"noopener noreferrer"},qn=n("p",null,"难度：简单",-1),Nn=n("p",null,[n("strong",null,"方法1：层序遍历")],-1),On=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),Tn=n("p",null,[s("空间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),Sn=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        depth <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
            depth <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
                    queue<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
        <span class="token keyword">return</span> depth
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：递归</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(logn)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            max_depth <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                max_depth <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                max_depth<span class="token punctuation">)</span>
        <span class="token keyword">return</span> max_depth <span class="token operator">+</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法3：栈</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>layers<span class="token punctuation">)</span><span class="token punctuation">:</span>
                layers<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            depth <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> depth<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        layers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        depth <span class="token operator">=</span> <span class="token number">0</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>layers<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_222-完全二叉树的节点个数" tabindex="-1"><a class="header-anchor" href="#_222-完全二叉树的节点个数" aria-hidden="true">#</a> 222. 完全二叉树的节点个数</h2>`,8),Ln={href:"https://leetcode.cn/problems/count-complete-tree-nodes/",target:"_blank",rel:"noopener noreferrer"},Mn=n("p",null,"难度：简单",-1),zn=n("p",null,[n("strong",null,"方法1：完全二叉树的特性")],-1),Fn=n("p",null,[s("使用树的遍历的话，时间复杂度都为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("，利用完全二叉树的特性：")],-1),Bn=n("p",null,[s("若其为满二叉树，则可以直接用公式计算总节点个数："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"h")]),n("mo",null,"−"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"2^{h}-1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.9324em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8491em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mathnormal mtight"},"h")])])])])])])])]),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])]),s("。"),n("strong",null,"注意根节点作为第0层，即此时h=0"),s("；若不为满二叉树，若继续递归下去，一定可以将其划分为左边为满二叉树，右边为完全二叉树的情况，这就类似于二分法。")],-1),Vn=n("p",null,[s("现在问题是，如何判断一棵完全二叉树是否为满二叉树？"),n("strong",null,"可以沿着left一直走下去，然后right一直走下去，两边的高度如果相等，则为满二叉树，否则不是"),s("。")],-1),Dn=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("msup",null,[n("mi",null,"g"),n("mn",null,"2")]),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(log^2n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),An=n("p",null,[s("空间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logn)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("。")],-1),jn=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        left_depth <span class="token operator">=</span> <span class="token number">0</span>
        right_depth <span class="token operator">=</span> <span class="token number">0</span>
        left <span class="token operator">=</span> root<span class="token punctuation">.</span>left
        right <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">while</span> left<span class="token punctuation">:</span>
            left_depth <span class="token operator">+=</span> <span class="token number">1</span>
            left <span class="token operator">=</span> left<span class="token punctuation">.</span>left
        <span class="token keyword">while</span> right<span class="token punctuation">:</span>
            right_depth <span class="token operator">+=</span> <span class="token number">1</span>
            right <span class="token operator">=</span> right<span class="token punctuation">.</span>right
        <span class="token keyword">if</span> left_depth <span class="token operator">==</span> right_depth<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">&lt;&lt;</span> left_depth<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_110-平衡二叉树" tabindex="-1"><a class="header-anchor" href="#_110-平衡二叉树" aria-hidden="true">#</a> 110. 平衡二叉树</h2>`,2),Pn={href:"https://leetcode.cn/problems/balanced-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Cn=a('<p>难度：简单</p><p><strong>方法1：层序遍历</strong></p><p>这种思路不对，因为平衡二叉树的定义是：每一个节点的左右子树的高度差不大于1，如果层序遍历的话，可以知道整棵树的最小高度和最大高度，但是这容易将满足平衡二叉树条件的误判为False。比如，下面是一棵平衡二叉树：</p><img title="" src="'+r+'" alt="" data-align="center" width="189"><p><strong>方法2：递归</strong></p><p>一个想法是：判断左子树是否平衡 &amp; 右子树是否平衡，进而判断整棵树是否平衡，这样可以嘛？比如：</p><img title="" src="'+k+`" alt="" data-align="center" width="84"><p>所以不能这样判断。</p><p><strong>一个思路是这样：后序遍历 + 剪枝 （从底至顶）</strong></p><p>这种思路判断每一个子树是否是平衡的方法是：若其左子树是平衡的，返回左子树的高度left；若右子树是平衡的，返回右子树的高度right；若左右子树有一个不是平衡的，返回-1；若左右子树都是平衡的，且二者的高度差|left-right| &lt;= 1，返回<strong>该子树的高度：max(left, right)+1</strong>，否则返回-1，表示这棵子树不是平衡的。</p><p>这里有一个需要理解的地方：若子树很简单，比如高度只有2层，很容易判断是否平衡，但是若像方法1那种情况，如何直接判断整棵树是否是平衡的呢？即节点1的左右子树的高度差不大于1，二者的高度应该取值多少呢？这里不要被绕晕了，树的高度这个定义还是不变，对于左子树的高度是3，而不是2，右子树高度是2，而不是1.</p><p>时间复杂度 O(N)： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。 空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>  <span class="token comment"># 由于一直有递归，需要判断临界情况</span>
        <span class="token comment"># 得到左子树的高度，若高度=-1，表示不平衡，直接断定整棵树不平衡，返回-1</span>
        left_depth <span class="token operator">=</span> self<span class="token punctuation">.</span>height<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">if</span> left_depth <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token comment"># 得到右子树的高度，若高度=-1，表示不平衡，直接断定整棵树不平衡，返回-1</span>
        right_depth <span class="token operator">=</span> self<span class="token punctuation">.</span>height<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">if</span> right_depth <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token comment"># 若左右子树的高度差&lt;=1，则返回整棵树的真正高度，否则表明不平衡，返回-1</span>
        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_depth<span class="token punctuation">,</span> right_depth<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span> \\
               <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_depth<span class="token operator">-</span>right_depth<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>height<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>另一个思路：先序遍历 + 判断深度 （从顶至底）</strong></p><p>若满足：abs(left_depth - right_depth) &lt;= 1，则平衡。用一个函数height来实现求树高的功能。</p><p>所以整体的流程是这样：若root.left的高度和root.right的高度相差&lt;=1，<strong>且root.left和root.right也平衡</strong>，则root平衡。后一个判断条件容易掉。</p><p>这样的做法有很多重复计算，即self.height(node)会被计算多次。</p>`,17),En=n("p",null,[n("strong",null,"时间复杂度"),s("：最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)=O(log⁡n)，因为 d≤h，所以总时间复杂度为 O(nlog⁡n)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])])],-1),In=a(`<p><strong>空间复杂度</strong>：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>height<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>height<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>

    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>height<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>height<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>isBalanced<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>isBalanced<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_257-二叉树的所有路径" tabindex="-1"><a class="header-anchor" href="#_257-二叉树的所有路径" aria-hidden="true">#</a> 257. 二叉树的所有路径</h2>`,3),Rn={href:"https://leetcode.cn/problems/binary-tree-paths/",target:"_blank",rel:"noopener noreferrer"},Kn=a(`<p>难度：简单</p><p><strong>方法1：回溯</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：平均O(logn)，最坏O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
               p <span class="token operator">=</span> <span class="token string">&#39;-&gt;&#39;</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
               ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
               <span class="token keyword">return</span>

            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
                backtrack<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
                path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
                backtrack<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
                path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        backtrack<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码看不出是什么顺序的遍历，用下面代码可以看出来是先序遍历：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 中</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
               p <span class="token operator">=</span> <span class="token string">&#39;-&gt;&#39;</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
               ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
               <span class="token keyword">return</span>

            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>  <span class="token comment"># 左</span>
                backtrack<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
                path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  <span class="token comment"># 右</span>
                backtrack<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
                path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        backtrack<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有一种更加简洁的递归，前面方法都是传递path列表，下面直接传递的是字符串，因为涉及到之前的路径、&#39;-&gt;&#39;、当前节点值，所以更加考验对递归的理解。写递归函数的时候，考虑这几个问题：</p><ol><li><p><strong>终止条件是什么？</strong></p></li><li><p><strong>一般情况下的代码怎么写？（递归到中间某个时刻）</strong></p></li><li><p><strong>结合初始状态，如何写能连接到下一个状态？</strong></p></li></ol><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
            path <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
            <span class="token keyword">return</span> 
        self<span class="token punctuation">.</span>backtrack<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>backtrack<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> path <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>backtrack<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>ans 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代dfs</strong></p><p>迭代麻烦在如何维护路径？是否可以拿一个path列表用于存储所有节点值，等叶子节点的时候使用&#39;-&gt;&#39;.join(path)，之后肯定要将叶子节点弹出，那么弹出多少个节点才可以？比如：</p><img title="" src="`+d+`" alt="" data-align="center" width="136"><p>上面情况得将5和2都弹出来，若2的左孩子不为空，那只能弹出5，所以若使用path列表来表示，这个弹出步骤会很麻烦（<strong>见路径总和2的那道题题解，已经有了解决方法</strong>）。</p><p>使用一个栈paths来存储路径，方法是每次从节点队列中弹出节点时，也弹出p（路径），若节点左右有不为空的，则必定演化出新的路径，将新的路径构造好压栈。<strong>注意路径压栈的顺序需要和节点的压栈顺序保持一致</strong>。</p><p>由于又多了一个路径栈的操作，总体用时和空间用时也增加了。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        paths <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        paths<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            p <span class="token operator">=</span> paths<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
                <span class="token keyword">continue</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                paths<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                paths<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法3：层序遍历</strong></p><p>和上一种方法一样，如果明白了如何操纵path就容易了，使用一个和node跟进的队列来存储路劲。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        q_node <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q_path <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        q_node<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        q_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">while</span> q_node<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q_node<span class="token punctuation">)</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q_node<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                p <span class="token operator">=</span> q_path<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
                    <span class="token keyword">continue</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    q_node<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                    q_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    q_node<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                    q_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_404-左叶子之和" tabindex="-1"><a class="header-anchor" href="#_404-左叶子之和" aria-hidden="true">#</a> 404. 左叶子之和</h2>`,21),Gn={href:"https://leetcode.cn/problems/sum-of-left-leaves/",target:"_blank",rel:"noopener noreferrer"},Hn=a(`<p>难度：简单</p><p><strong>方法1：迭代+dfs</strong></p><p>思路：若一个节点右节点不为空，则入栈；若左节点不为空，左节点为叶子节点，值加入ans；若左节点不为空，左节点不是叶子节点，入栈.</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  <span class="token comment"># 右边不为空，入栈</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>  <span class="token comment"># 左边不为空</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 叶子节点</span>
                    ans <span class="token operator">+=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val
                <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 不为叶子节点，入栈</span>
                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：层序遍历</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">is_leaf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_leaf<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        ans <span class="token operator">+=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法3：递归</strong></p><p>拿到本题没有深入思考的时候，总觉得递归做不了，迭代才可以做，其实递归过程，将节点传入递归函数的步骤就相当于迭代版本的入栈步骤，所以迭代可以完成的，递归也可以。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">is_leaf</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token triple-quoted-string string">&quot;&quot;&quot;该函数的作用是：返回以node为根节点的子树内
                所有左叶子节点的值
            &quot;&quot;&quot;</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
            ans <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  <span class="token comment"># 看函数的功能，所以ans要加其返回值</span>
                ans <span class="token operator">+=</span> dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>is_leaf<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    ans <span class="token operator">+=</span> dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  <span class="token comment"># 看函数的功能，所以ans要加其返回值</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    ans <span class="token operator">+=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val
            <span class="token keyword">return</span> ans
        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_513-找树左下角的值" tabindex="-1"><a class="header-anchor" href="#_513-找树左下角的值" aria-hidden="true">#</a> 513. 找树左下角的值</h2>`,10),Jn={href:"https://leetcode.cn/problems/find-bottom-left-tree-value/",target:"_blank",rel:"noopener noreferrer"},Qn=a(`<p>难度：中等</p><p><strong>方法1：层序遍历</strong></p><p>每次取每一层中的第一个节点值</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span>
            ans <span class="token operator">=</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代dfs</strong></p><p>迭代遍历树，遍历同时记录路径的长度，若遇到叶子结点，则比较路径长度，若路径比已存结果更长，则说明叶子节点更深，则保留</p><blockquote><p>因为我们先遍历左子树，然后再遍历右子树，所以对同一高度的所有节点，<strong>最左节点肯定是最先被遍历到的</strong>。</p></blockquote><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        path <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># node val, path length</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            p_len <span class="token operator">=</span> path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> p_len <span class="token operator">&gt;</span> ans<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>val
                    ans<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> p_len

            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p_len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p_len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法3：递归</strong></p><p>使用一个额外的cur_depth用来存，上一个从根节点到叶子结点的路径长度。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findBottomLeftValue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">global</span> cur_depth
            <span class="token keyword">global</span> ans
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span> 
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 叶子节点</span>
                <span class="token keyword">if</span> depth <span class="token operator">&gt;</span> cur_depth<span class="token punctuation">:</span>
                    ans <span class="token operator">=</span> node<span class="token punctuation">.</span>val
                    cur_depth <span class="token operator">=</span> depth
                <span class="token keyword">return</span> 
            depth <span class="token operator">+=</span> <span class="token number">1</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>

        <span class="token keyword">global</span> ans
        ans <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">global</span> cur_depth
        cur_depth <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_112-路径总和" tabindex="-1"><a class="header-anchor" href="#_112-路径总和" aria-hidden="true">#</a> 112. 路径总和</h2>`,12),Un={href:"https://leetcode.cn/problems/path-sum/",target:"_blank",rel:"noopener noreferrer"},Wn=a(`<p>难度：简单</p><p><strong>方法1：递归</strong></p><p>在写递归的时候，一开始陷入了这样的问题：如何实现像回溯那样，选中一个值之后，出来去除这个值。</p><p>这其实在递归函数中，传递这个值就可以解决，因为进入递归函数，会再创建一个新的整形变量，退出函数后，上一层的该整型变量值是不变的，所以不用去考虑怎么减掉加入的值。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> sum_num<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span>
            <span class="token keyword">nonlocal</span> ans
            sum_num <span class="token operator">+=</span> node<span class="token punctuation">.</span>val
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> sum_num <span class="token operator">==</span> targetSum<span class="token punctuation">:</span>
                    ans <span class="token operator">=</span> <span class="token boolean">True</span>
                <span class="token keyword">return</span>

            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum_num<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum_num<span class="token punctuation">)</span>

        ans <span class="token operator">=</span> <span class="token boolean">False</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一种更简洁的递归：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            <span class="token keyword">if</span> targetSum <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>hasPathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>hasPathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代dfs</strong></p><p>涉及到树中的路径，或者使用递归，或者使用一个栈来存储路径，即使用额外的空间来存储逃不掉。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        q_sum <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            sum_val <span class="token operator">=</span> q_sum<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> sum_val <span class="token operator">==</span> targetSum<span class="token punctuation">:</span>
                    <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                q_sum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sum_val <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                q_sum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sum_val <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_113-路径总和2" tabindex="-1"><a class="header-anchor" href="#_113-路径总和2" aria-hidden="true">#</a> 113. 路径总和2</h2>`,11),Xn={href:"https://leetcode.cn/problems/path-sum-ii/",target:"_blank",rel:"noopener noreferrer"},Yn=n("p",null,"难度：中等",-1),Zn=n("p",null,[n("strong",null,"方法1：递归")],-1),$n=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"N"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(N^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为 O(N)，并且每一条路径的节点个数也为 O(N).")],-1),ns=a(`<p>空间复杂度：O(N)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> path<span class="token punctuation">,</span> cur_sum<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span>
            <span class="token keyword">nonlocal</span> ans
            cur_sum <span class="token operator">+=</span> node<span class="token punctuation">.</span>val
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                <span class="token keyword">if</span> cur_sum <span class="token operator">==</span> targetSum<span class="token punctuation">:</span>
                    path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> 
            <span class="token comment"># 遍历路径一定涉及到，添加了一个节点之后，要去除该节点</span>
            <span class="token comment"># 这里的path如何去除？可以通过进入将path创建新的副本来解决</span>
            <span class="token comment"># 比如这里：path-&gt;path+[node.val]</span>
            <span class="token comment"># 不能直接传入path，因为python会只维护一个path，这样就没有</span>
            <span class="token comment"># 去除节点的步骤，除非显式path.pop，但是由于path进入了后续的迭代</span>
            <span class="token comment"># 无法保证path最后的节点就是当前的node</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> path <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span> cur_sum<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> path <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span> cur_sum<span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment"># 注意初始状态：有根节点，但是path和cur_sum都为空</span>
        <span class="token comment"># 即后两者都比根节点慢一个状态</span>
        <span class="token comment"># 所以递归函数里也要保持这样的对应状态</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面方法的空间复杂度较高，因为有很多的path副本，只用一个全局path就节省很多内存，那么如何回退呢？即遇到了叶子结点，应该将path加入ans，接下来肯定要回退，应该弹出多少个节点呢？<strong>如果这样想就很难解决了，应该利用递归来回退</strong>，具体如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        ret <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        path <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
                <span class="token keyword">return</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            targetSum <span class="token operator">-=</span> root<span class="token punctuation">.</span>val
            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right <span class="token keyword">and</span> targetSum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span>
            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 回退</span>

        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> targetSum<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析上述代码为何能回退，假设某一次root已经是叶子结点了，那么继续进入后续的dfs，会触发if not root语句。最终回退该叶子节点。若不是叶子节点，以如下例子为例，假设刚刚找到了5, 4, 11, 7这条路径，刚刚回退了7，现在到了root是11的节点，接下来执行dfs(root.right, targetSum)，同样的会回退2，然后再执行path.pop()，会回退11，所以这里模拟一下会发现，<strong>访问过的节点不会再次访问了，每一次都要回退，而且回退的是最新加入的节点，这就完成了目标</strong>。</p><img title="" src="`+v+`" alt="" data-align="center" width="232"><p><strong>方法2：层序遍历</strong></p><p>使用一个队列存储路径，使得和当前遍历的节点对应；使用一个队列存储路径和，使得和当前遍历的节点对应。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        paths <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        q_sum <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            sz <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                p <span class="token operator">=</span> paths<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                sum_val <span class="token operator">=</span> q_sum<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>right <span class="token keyword">and</span> sum_val <span class="token operator">==</span> targetSum<span class="token punctuation">:</span>
                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
                    <span class="token keyword">continue</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> 
                    q_sum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sum_val <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                    paths<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    q_sum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sum_val <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                    paths<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_106-从中序和后续遍历构造二叉树" tabindex="-1"><a class="header-anchor" href="#_106-从中序和后续遍历构造二叉树" aria-hidden="true">#</a> 106. 从中序和后续遍历构造二叉树</h2><blockquote><p>利用两种遍历就可以确定一颗二叉数的确定形状，但是已知的遍历中<strong>必须有中序遍历</strong>。先序遍历与后续遍历不一定能唯一确定一个二叉树.</p></blockquote>`,11),ss={href:"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",target:"_blank",rel:"noopener noreferrer"},as=a(`<p>难度：中等</p><p><strong>方法1：递归</strong></p><p>思路是：</p><ul><li><p>先利用后序序列找到根节点，在中序中找到该节点位置，将 左右子树的中序序列 划分出来</p></li><li><p>由于后序遍历和中序遍历的长度相等，所以根据左右子树的中序序列，可以从后续序列中划分出 左右子树的后续序列。</p></li><li><p>将划分出来的 左右子树的中序、后续序列 递归处理</p></li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> r1 <span class="token operator">&lt;</span> l1<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>
        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>r2<span class="token punctuation">]</span><span class="token punctuation">)</span>
        mid <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>postorder<span class="token punctuation">[</span>r2<span class="token punctuation">]</span><span class="token punctuation">]</span>
        left_mid_b <span class="token operator">=</span> l1
        left_mid_e <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>
        right_mid_b <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        right_mid_e <span class="token operator">=</span> r1

        left_post_b <span class="token operator">=</span> l2
        left_post_e <span class="token operator">=</span> left_mid_e <span class="token operator">-</span> left_mid_b <span class="token operator">+</span> left_post_b
        right_post_b <span class="token operator">=</span> left_post_e <span class="token operator">+</span> <span class="token number">1</span>
        right_post_e <span class="token operator">=</span> r2 <span class="token operator">-</span> <span class="token number">1</span>

        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> left_mid_b<span class="token punctuation">,</span> left_mid_e<span class="token punctuation">,</span> left_post_b<span class="token punctuation">,</span> left_post_e<span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> right_mid_b<span class="token punctuation">,</span> right_mid_e<span class="token punctuation">,</span> right_post_b<span class="token punctuation">,</span> right_post_e<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root

    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> inorder<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span><span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> 
                <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
                <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>postorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代</strong></p><h2 id="_105-从前序和中序遍历构造二叉树" tabindex="-1"><a class="header-anchor" href="#_105-从前序和中序遍历构造二叉树" aria-hidden="true">#</a> 105. 从前序和中序遍历构造二叉树</h2>`,7),ts={href:"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",target:"_blank",rel:"noopener noreferrer"},ps=a(`<p>难度：中等</p><p><strong>方法1：递归</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> l1 <span class="token operator">&gt;</span> r1<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>
        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>self<span class="token punctuation">.</span>preorder<span class="token punctuation">[</span>l1<span class="token punctuation">]</span><span class="token punctuation">)</span>
        mid <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>preorder<span class="token punctuation">[</span>l1<span class="token punctuation">]</span><span class="token punctuation">]</span>

        left_mid_b <span class="token operator">=</span> l2
        left_mid_e <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>
        right_mid_b <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
        right_mid_e <span class="token operator">=</span> r2

        left_pre_b <span class="token operator">=</span> l1 <span class="token operator">+</span> <span class="token number">1</span>
        left_pre_e <span class="token operator">=</span> left_mid_e <span class="token operator">-</span> left_mid_b <span class="token operator">+</span> left_pre_b
        right_pre_b <span class="token operator">=</span> left_pre_e <span class="token operator">+</span> <span class="token number">1</span>
        right_pre_e <span class="token operator">=</span> r1
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>left_pre_b<span class="token punctuation">,</span> left_pre_e<span class="token punctuation">,</span> left_mid_b<span class="token punctuation">,</span> left_mid_e<span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>right_pre_b<span class="token punctuation">,</span> right_pre_e<span class="token punctuation">,</span> right_mid_b<span class="token punctuation">,</span> right_mid_e<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root

    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> preorder<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>preorder <span class="token operator">=</span> preorder
        self<span class="token punctuation">.</span>inorder <span class="token operator">=</span> inorder
        self<span class="token punctuation">.</span><span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i

        <span class="token keyword">return</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_654-最大二叉树" tabindex="-1"><a class="header-anchor" href="#_654-最大二叉树" aria-hidden="true">#</a> 654. 最大二叉树</h2>`,6),es={href:"https://leetcode.cn/problems/maximum-binary-tree/",target:"_blank",rel:"noopener noreferrer"},os=n("p",null,"难度：中等",-1),cs=n("p",null,[n("strong",null,"方法1：递归+暴力")],-1),ls=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("，每一次从剩余的nums选出最大值，选一个的复杂度为O(n)，要选出n个。")],-1),is=a(`<p>空间复杂度：O(n)，最坏情况的递归栈深度。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>
        max_val <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span>
        idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max_val<span class="token punctuation">:</span>
                max_val <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                idx <span class="token operator">=</span> i
        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>max_val<span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>constructMaximumBinaryTree<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span> idx<span class="token punctuation">]</span><span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>constructMaximumBinaryTree<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：单调栈</strong></p><p>遍历nums，维护一个单调栈，栈顶元素最小，若nums[i]&lt;栈顶，表示nums[i]是nums[: i+1]内最小的，那么其左子结点为None；若nums[i]&gt;栈顶，则需要找到栈内不大于nums[i]的最大值val（不断出栈），并nums[i].left=val(这里为了方便直接作为节点来描述)，然后弹出val（一个节点只有一个父节点）；<strong>未完成...</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        stk <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> n

        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">while</span> stk <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">=</span> tree<span class="token punctuation">[</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                stk<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> stk<span class="token punctuation">:</span>
                tree<span class="token punctuation">[</span>stk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">=</span> tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            stk<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> tree<span class="token punctuation">[</span>stk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_617-合并二叉树" tabindex="-1"><a class="header-anchor" href="#_617-合并二叉树" aria-hidden="true">#</a> 617. 合并二叉树</h2>`,8),us={href:"https://leetcode.cn/problems/merge-two-binary-trees/",target:"_blank",rel:"noopener noreferrer"},rs=a(`<p>难度：简单</p><p><strong>方法1：递归</strong></p><p>和遍历一棵树一样，只是这里需要传入两个树，以root1为主，若二者都为空，返回空；若root1为空，则合并之后root1=root2；若root2为空，合并前后root1无变化，直接返回root1；若二者都不为空，合并之后为二者值之和。</p><p>随后遍历二者的左、右子树，并更新root1的左、右子树（因为原root1的左、右子树可能为空）。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> root2<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root1 <span class="token keyword">and</span> <span class="token keyword">not</span> root2<span class="token punctuation">:</span> <span class="token comment"># 二者均为空</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root1<span class="token punctuation">:</span> <span class="token comment"># root1为空</span>
            root1 <span class="token operator">=</span> root2
            <span class="token keyword">return</span> root1
        <span class="token keyword">if</span> <span class="token keyword">not</span> root2<span class="token punctuation">:</span>  <span class="token comment"># root2为空</span>
            <span class="token keyword">return</span> root1
        root1<span class="token punctuation">.</span>val <span class="token operator">+=</span> root2<span class="token punctuation">.</span>val
        root1<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        root1<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        <span class="token keyword">return</span> root1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然也可以不修改原输入的root1和root2：</p><p>时间复杂度：O(min(m, n))，m和n分别为两棵树的节点总数</p><p>空间复杂度：O(min(m, n))，这是最坏的情况，一般情况为两棵树的高度的最小值</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t1<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> t2<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> t1<span class="token punctuation">:</span>
            <span class="token keyword">return</span> t2
        <span class="token keyword">if</span> <span class="token keyword">not</span> t2<span class="token punctuation">:</span>
            <span class="token keyword">return</span> t1
        
        merged <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>val <span class="token operator">+</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        merged<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        merged<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTrees<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> merged
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：层序遍历</strong></p><p>有很多细节很容易错，比如经典的层序遍历有一个for循环，遍历每一层的数值，这里可以省略，加上了for反而更麻烦，这里同步更新三个队列，在层序遍历三棵树的同时，完成新树的节点之间的关联。之前的思路是：若两棵树的子节点都存在，则累加值；若一个不存在，则保留存在的。“保留存在的” 不用去新建一个节点，将值赋给它，可以直接将节点连接到新树上。</p><p>时间复杂度和空间复杂度和上一种方法一样。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root1<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> root2<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root1<span class="token punctuation">:</span> <span class="token keyword">return</span> root2
        <span class="token keyword">if</span> <span class="token keyword">not</span> root2<span class="token punctuation">:</span> <span class="token keyword">return</span> root1
        merged <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val<span class="token operator">+</span>root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>merged<span class="token punctuation">]</span><span class="token punctuation">)</span>
        queue1 <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root1<span class="token punctuation">]</span><span class="token punctuation">)</span>
        queue2 <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root2<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> queue1 <span class="token keyword">and</span> queue2<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node1 <span class="token operator">=</span> queue1<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node2 <span class="token operator">=</span> queue2<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node1<span class="token punctuation">.</span>left <span class="token keyword">or</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                <span class="token keyword">if</span> node1<span class="token punctuation">.</span>left <span class="token keyword">and</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">:</span> 
                    left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">+</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                    node<span class="token punctuation">.</span>left <span class="token operator">=</span> left  <span class="token comment"># 容易漏</span>
                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">)</span>
                    queue1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                    queue2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">elif</span> node1<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    node<span class="token punctuation">.</span>left <span class="token operator">=</span> node1<span class="token punctuation">.</span>left  <span class="token comment"># 容易漏</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    node<span class="token punctuation">.</span>left <span class="token operator">=</span> node2<span class="token punctuation">.</span>left  <span class="token comment"># 容易漏</span>
            <span class="token keyword">if</span> node1<span class="token punctuation">.</span>right <span class="token keyword">or</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                <span class="token keyword">if</span> node1<span class="token punctuation">.</span>right <span class="token keyword">and</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">:</span> 
                    right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">+</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                    node<span class="token punctuation">.</span>right <span class="token operator">=</span> right  <span class="token comment"># 容易漏</span>
                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">)</span>
                    queue1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                    queue2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                <span class="token keyword">elif</span> node1<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                    node<span class="token punctuation">.</span>right <span class="token operator">=</span> node1<span class="token punctuation">.</span>right  <span class="token comment"># 容易漏</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    node<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">.</span>right  <span class="token comment"># 容易漏</span>
        <span class="token keyword">return</span> merged
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_236-二叉树的最近公共祖先" tabindex="-1"><a class="header-anchor" href="#_236-二叉树的最近公共祖先" aria-hidden="true">#</a> 236. 二叉树的最近公共祖先</h2>`,14),ks={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/",target:"_blank",rel:"noopener noreferrer"},ds=a(`<p>难度：中等</p><p><strong>方法1：存储父节点</strong></p><p>思路：先遍历一遍树，将每一个节点的父节点存入哈希表；再从p往上遍历，记录路径path的节点；再从q往上遍历，若遇到某个节点在路径path里出现过，则该点就是最近公共祖先。</p><p>时间复杂度：最坏情况是O(2n)</p><p>空间复杂度：最坏情况是O(3n)：hash表里的键和值以及path</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">update_hash</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;将树中所有节点的父节点存入hash &quot;&quot;&quot;</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> 
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> root
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> root
        self<span class="token punctuation">.</span>update_hash<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>update_hash<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span><span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token punctuation">{</span>root<span class="token punctuation">.</span>val<span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">}</span>
        <span class="token comment"># 先将所有节点的父节点存入哈希表</span>
        self<span class="token punctuation">.</span>update_hash<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        path <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 从p往上遍历，并记录经过的节点</span>
        <span class="token keyword">while</span> p<span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>add<span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            p <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
        <span class="token comment"># 从 q往上遍历，看是否在path中出现过</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            <span class="token keyword">if</span> q<span class="token punctuation">.</span>val <span class="token keyword">in</span> path<span class="token punctuation">:</span> <span class="token keyword">return</span> q
            q <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>q<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：递归</strong></p>`,7),vs={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solutions/240096/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/",target:"_blank",rel:"noopener noreferrer"},ms=a(`<p>时间复杂度：O(n)</p><p>空间复杂度：O(n) （最坏）</p><p>利用递归，<strong>从下往上遍历</strong>。对于每一个遍历到的节点，看其左子树和右子树是否有p和q。</p><p>若左右都无，那这个节点肯定不是公共祖先；若左右各一个，则当前节点就是最近公共祖先；若左右只有一个包含了p或q，返回包含的那一边。</p><p>最后一句“返回包含的那一边”有点难理解，这个函数<code>lowestCommonAncesto</code>到底实现的是什么功能？我们期待的是实现 直接找到最近公共祖先 的功能。但是是从下往上遍历的，可能一下子找不到，要慢慢往上回溯才行。如果我们返回包含了p或q的那一边（假设left包含了p），那么上一层就会返回其父节点，以此类推其实实现的就是不断延伸从 p到root 的路径。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">:</span>
        <span class="token comment"># None, root = p, root = q 返回 root</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root <span class="token keyword">or</span> root <span class="token operator">==</span> p <span class="token keyword">or</span> root <span class="token operator">==</span> q<span class="token punctuation">:</span> <span class="token keyword">return</span> root
        left <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">and</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span> <span class="token comment"># 都为空</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> left<span class="token punctuation">:</span> <span class="token keyword">return</span> right  <span class="token comment"># 左为空</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span> <span class="token keyword">return</span> left  <span class="token comment"># 右为空</span>
        <span class="token keyword">return</span> root  <span class="token comment"># 左右都不为空</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二叉搜索树" tabindex="-1"><a class="header-anchor" href="#二叉搜索树" aria-hidden="true">#</a> 二叉搜索树</h2><h3 id="_700-二叉搜索树中的搜索" tabindex="-1"><a class="header-anchor" href="#_700-二叉搜索树中的搜索" aria-hidden="true">#</a> 700. 二叉搜索树中的搜索</h3>`,8),bs={href:"https://leetcode.cn/problems/search-in-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},hs=a(`<p>难度：简单</p><p><strong>递归</strong></p><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote><p>二叉搜索树：树的左子树所有val都小于root.val，树的右子树所有val都大于root.val。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># Definition for a binary tree node.</span>
<span class="token comment"># class TreeNode:</span>
<span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="token comment">#         self.val = val</span>
<span class="token comment">#         self.left = left</span>
<span class="token comment">#         self.right = right</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">if</span> val <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        <span class="token keyword">elif</span> val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>searchBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>迭代</strong></p><blockquote><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p></blockquote><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> root <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">!=</span> val<span class="token punctuation">:</span>
            <span class="token keyword">if</span> val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            <span class="token keyword">elif</span> val <span class="token operator">&gt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_98-验证二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_98-验证二叉搜索树" aria-hidden="true">#</a> 98. 验证二叉搜索树</h3>`,9),ys={href:"https://leetcode.cn/problems/validate-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},gs=a(`<p>难度：中等</p><p><strong>这里有一个错误的思路</strong>，其实质是没有对二叉搜索树理解透，其做法是让每一个节点都保证：node.left.val &lt; node.val &lt; node.right.val，则就是二叉搜索树，代码如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>
        curr_compair <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                curr_compair <span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                curr_compair <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                curr_compair <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                curr_compair <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token boolean">False</span>
        curr_compair <span class="token operator">&amp;</span><span class="token operator">=</span> self<span class="token punctuation">.</span>isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        curr_compair <span class="token operator">&amp;</span><span class="token operator">=</span> self<span class="token punctuation">.</span>isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> curr_compair
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样为什么不对？比如下例：</p><img title="" src="`+m+`" alt="" data-align="center" width="196"><p>这就容易看出来错误在：仅仅保证了满足<strong>左右子节点</strong>，但是二叉搜索树要求node的<strong>左子树的所有节点值</strong>都&lt;node.val&lt;node的<strong>右子树的所有节点值</strong>。</p><p><strong>方法1：递归</strong></p><p>在上面的思路基础上，又想着能否找到左子树的最大值max、右子树的最小值min，若满足：max&lt;node.val &lt;min则就是二叉搜索树。但是实现起来会很麻烦，进一步思考，<strong>中序遍历其实就是一组 左中右左中右左中右...序列，若能保证 左&lt; 中&lt; 右 &lt; 左 &lt; 中 &lt; 右....就说明是BST</strong>。</p><p>第一个思路是：中序遍历中每一个节点大于前一个值，小于后一个值，那么就是BST。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> upper<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 当前节点满足上下界关系</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>lower <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> upper<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token comment"># 左节点满足上下界关系</span>
            <span class="token comment"># 左节点的下界为何是lower？</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token comment"># 右节点满足上下界关系</span>
            <span class="token comment"># 右节点的上界为何是upper?</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">,</span> upper<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>at<span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>第二个思路：这里是同时顾及两端，其实不用顾及两端，只用顾及一端即可。这里怎么顾及一端呢，每次保留当前的node.val，和下一个node.val比较即可，而不用将当前的node.val和前一个、后一个都比较。</p><p>为什么这样就可以避免上面说的错误思路相同的错误呢？<strong>因为上面错误思路其实只能保证：左&lt; 中&lt; 右，而这个做法可以跨子树，即：左&lt; 中&lt; 右 &lt; 左&lt; 中&lt; 右</strong> ...</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    pre <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 左子树不满足</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token comment"># 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，</span>
        <span class="token comment"># 说明不满足BST</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>pre <span class="token operator">&gt;=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        self<span class="token punctuation">.</span>pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：迭代</strong></p><p>迭代版本的中序遍历</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        pre <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span>

        <span class="token keyword">while</span> stack <span class="token keyword">or</span> root<span class="token punctuation">:</span>
            <span class="token keyword">while</span> root<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left

            root <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> pre <span class="token operator">&gt;=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
            pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_530-二叉树的最小绝对差" tabindex="-1"><a class="header-anchor" href="#_530-二叉树的最小绝对差" aria-hidden="true">#</a> 530. 二叉树的最小绝对差</h3>`,22),fs={href:"https://leetcode.cn/problems/minimum-absolute-difference-in-bst/",target:"_blank",rel:"noopener noreferrer"},ws=a(`<p>难度：简单</p><p>这个最小值肯定存在于中序遍历序列的相邻节点中，所以还是考察中序遍历。</p><p><strong>方法1：迭代中序遍历</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        ans <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span>
        stack <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        pre <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> stack <span class="token keyword">or</span> root<span class="token punctuation">:</span>
            <span class="token keyword">while</span> root<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">)</span> <span class="token operator">&lt;</span> ans<span class="token punctuation">:</span>
                ans <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">)</span>
            pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：递归</strong></p><p>递归代码少，但是不容易写对。思路是用中序遍历写，可以先把框架写好：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
    ans <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span>
        dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token comment"># process node</span>
        dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面就要着手 <code>process node</code> 那部分代码，用一个<code>pre</code>变量存储<strong>中序遍历序列中，当前节点的前一个节点值</strong>。该怎么存呢？其实不用去刻意想太多，因为<code>dfs</code>函数就是实现的中序遍历，假设我们提前将中序序列写出来，那么每次进入<code>dfs</code>其实就是<strong>按顺序遍历中序序列</strong>。那么如何存储顺序遍历序列中的前一个值？直接用一个全局变量<code>pre</code>存当前的<code>node.val</code>不就可以了，那对下一个<code>node</code>而言，<code>pre</code>就是前一个遍历过的节点值。那么<code>ans</code>的更新就容易了：</p>`,10),_s=n("p",{class:"katex-block"},[n("span",{class:"katex-display"},[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[n("semantics",null,[n("mrow",null,[n("mi",null,"a"),n("mi",null,"n"),n("mi",null,"s"),n("mo",null,"="),n("mi",null,"min"),n("mo",null,"⁡"),n("mo",{stretchy:"false"},"("),n("mi",null,"a"),n("mi",null,"n"),n("mi",null,"s"),n("mo",{separator:"true"},","),n("mi",{mathvariant:"normal"},"∣"),n("mi",null,"n"),n("mi",null,"o"),n("mi",null,"d"),n("mi",null,"e"),n("mi",{mathvariant:"normal"},"."),n("mi",null,"v"),n("mi",null,"a"),n("mi",null,"l"),n("mo",null,"−"),n("mi",null,"p"),n("mi",null,"r"),n("mi",null,"e"),n("mi",{mathvariant:"normal"},"∣"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"}," ans = \\min(ans, |node.val - pre|) ")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"an"),n("span",{class:"mord mathnormal"},"s"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mop"},"min"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"an"),n("span",{class:"mord mathnormal"},"s"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},"∣"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal"},"d"),n("span",{class:"mord mathnormal"},"e"),n("span",{class:"mord"},"."),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),n("span",{class:"mord mathnormal"},"a"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"−"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"p"),n("span",{class:"mord mathnormal"},"re"),n("span",{class:"mord"},"∣"),n("span",{class:"mclose"},")")])])])])],-1),xs=a(`<p>初始<code>pre</code>肯定视为无效的，为此防止多加一个<code>if</code>判断语句，可以将<code>pre</code>初始化为无穷小。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        ans <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span>
        pre <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span>
            <span class="token keyword">nonlocal</span> ans<span class="token punctuation">,</span> pre
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            ans <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">)</span><span class="token punctuation">)</span>
            pre <span class="token operator">=</span> node<span class="token punctuation">.</span>val
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_501-二叉搜索树中的众数" tabindex="-1"><a class="header-anchor" href="#_501-二叉搜索树中的众数" aria-hidden="true">#</a> 501. 二叉搜索树中的众数</h3>`,3),qs={href:"https://leetcode.cn/problems/find-mode-in-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},Ns=a(`<p>难度：简单</p><p><strong>方法1：两次遍历</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p>通解简单，先遍历一遍二叉树，统计所有节点数值的频次，再次遍历，从中选出最大的。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span>
        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">findMode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span><span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>  <span class="token comment"># 第一次遍历二叉树，统计频次</span>

        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        pre <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> self<span class="token punctuation">.</span><span class="token builtin">hash</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 第二次遍历，找最大频次的数</span>
            <span class="token keyword">if</span> v <span class="token operator">==</span> pre<span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
            <span class="token keyword">if</span> v <span class="token operator">&gt;</span> pre<span class="token punctuation">:</span>
                ans<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
                pre <span class="token operator">=</span> v
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：一次遍历</strong></p><p>这种方法最好写的时候按照逻辑来一步一步实现，不要想着笼统全部实现，很容易弄乱，绕不出来。注意，有两种特殊的情况：1. 多个众数。这种情况会有times == max_time，此时直接加入ans即可；2. times &gt; max_time。说明之前加入ans的都不是众数，需要清空ans。</p><p>所以不能直接处理 times &gt;= max_time，而要分开处理。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findMode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        pre <span class="token operator">=</span> <span class="token boolean">None</span>  <span class="token comment"># 前一个遍历的节点</span>
        max_time <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 最大出现次数</span>
        times <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 当前数值的节点出现的次数</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span>
            <span class="token keyword">nonlocal</span> pre<span class="token punctuation">,</span> times<span class="token punctuation">,</span> max_time<span class="token punctuation">,</span> ans
            <span class="token comment"># 左</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  
            <span class="token comment"># 中。写这部分代码的时候最好将不同的步骤区分开来</span>
            <span class="token comment"># 逻辑要清晰，不然很容易绕不出来</span>
            <span class="token comment">## 第一步：更新times</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> pre<span class="token punctuation">:</span> 
                times <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> pre<span class="token punctuation">.</span>val <span class="token operator">==</span> node<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                times <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                times <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token comment">## 第二步：更新pre</span>
            pre <span class="token operator">=</span> node
            <span class="token comment">## 第三步：更新ans和max_time</span>
            <span class="token comment">## 这一步注意这两种情况：可能有多个众数</span>
            <span class="token keyword">if</span> times <span class="token operator">==</span> max_time<span class="token punctuation">:</span> ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token comment">## 还有一情况：可能之前统计的都不是众数</span>
            <span class="token keyword">if</span> times <span class="token operator">&gt;</span> max_time<span class="token punctuation">:</span> 
                ans<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
                ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                max_time <span class="token operator">=</span> times
            <span class="token comment"># 右</span>
            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_235-二叉搜索树的最近公共祖先" tabindex="-1"><a class="header-anchor" href="#_235-二叉搜索树的最近公共祖先" aria-hidden="true">#</a> 235. 二叉搜索树的最近公共祖先</h3>`,11),Os={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},Ts=a(`<p>难度：中等</p><p>本次利用 234.二叉树的最近公共祖先 的解法提交可以通过，但是耗时较多。还是要体现出二叉搜索树的特点。</p><p><strong>方法1：两次遍历</strong></p><p>结合二叉搜索树的特点，给定根节点，一个树内的节点，可以用O(len)的复杂度到达该节点， len为从root到该节点的路径长度。</p><p>利用上述的优势，先从root-&gt;p，将沿途节点计入set，再从root-&gt;q，沿途判断是否出现在set里，若出现了记为ans，将最新的ans值返回即可。</p><p>时间复杂度：O(len1+len2)，len1和len2分别为两个节点到root的距离</p><p>空间复杂度：O(len1)。</p><p>最坏的情况，len1和len2都接近n。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">:</span>
        path <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        begin <span class="token operator">=</span> root
        <span class="token comment"># 先将从root -&gt; p的路径的节点都加入集合</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>add<span class="token punctuation">(</span>begin<span class="token punctuation">)</span>
            <span class="token keyword">if</span> p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> begin<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                begin <span class="token operator">=</span> begin<span class="token punctuation">.</span>left
            <span class="token keyword">elif</span> p<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> begin<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                begin <span class="token operator">=</span> begin<span class="token punctuation">.</span>right
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        <span class="token comment"># 开始从root-&gt;q，若遇到某个节点在集合内, 更新ans</span>
        ans <span class="token operator">=</span> <span class="token boolean">None</span>
        begin <span class="token operator">=</span> root
        <span class="token keyword">while</span> begin <span class="token operator">!=</span> q<span class="token punctuation">.</span>left<span class="token punctuation">:</span>  <span class="token comment"># 这里为了让q也加入判断，所以多往下走一层</span>
            <span class="token keyword">if</span> begin <span class="token keyword">in</span> path<span class="token punctuation">:</span>
                ans <span class="token operator">=</span> begin
            <span class="token keyword">if</span> begin<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                begin <span class="token operator">=</span> begin<span class="token punctuation">.</span>left
            <span class="token keyword">elif</span> begin<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                begin <span class="token operator">=</span> begin<span class="token punctuation">.</span>right
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                begin <span class="token operator">=</span> begin<span class="token punctuation">.</span>left
        <span class="token keyword">return</span> ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法2：一次遍历</strong></p><p>方法1遍历了两次，一次是root-&gt;p，然后一次是root-&gt;q。其实一次遍历也可以：</p><ul><li><p>若node.val小于p.val和q.val，说明p和q位于node的右子树，需要node=node.right</p></li><li><p>若node.val大于p.val和q.val，说明p和q位于node的左子树，需要node=node.left</p></li><li><p>若不满足上述两个要求，则node一定是位于分叉位置，即左右分别是p和q 或者 node刚好=p或q。直接返回node即可。</p></li></ul><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">:</span>
        ancester <span class="token operator">=</span> root
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> ancester<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token keyword">and</span> ancester<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                ancester <span class="token operator">=</span> ancester<span class="token punctuation">.</span>right
            <span class="token keyword">elif</span> ancester<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>val <span class="token keyword">and</span> ancester<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                ancester <span class="token operator">=</span> ancester<span class="token punctuation">.</span>left
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
        <span class="token keyword">return</span> ancester
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_701-二叉搜索树的插入操作" tabindex="-1"><a class="header-anchor" href="#_701-二叉搜索树的插入操作" aria-hidden="true">#</a> 701. 二叉搜索树的插入操作</h3>`,16),Ss={href:"https://leetcode.cn/problems/insert-into-a-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},Ls=n("p",null,"难度：中等",-1),Ms=n("p",null,"方法1：",-1);function zs(Fs,Bs){const t=o("ExternalLinkIcon");return c(),l("div",null,[h,n("p",null,[n("a",y,[s("代码随想录"),p(t)])]),g,f,w,n("p",null,[s("题目："),n("a",_,[s("144. 二叉树的前序遍历"),p(t)])]),x,q,N,O,T,S,L,n("p",null,[s("题目："),n("a",M,[s("145. 二叉树的后序遍历"),p(t)])]),z,n("p",null,[s("题目："),n("a",F,[s("102. 二叉树的层序遍历"),p(t)])]),B,n("p",null,[s("题目："),n("a",V,[s("107. 二叉树的层序遍历 II"),p(t)])]),D,A,j,P,C,n("p",null,[s("题目："),n("a",E,[s("199. 二叉树的右视图"),p(t)])]),I,n("p",null,[s("题目："),n("a",R,[s("637. 二叉树的层平均值"),p(t)])]),K,n("p",null,[s("题目："),n("a",G,[s("429. N 叉树的层序遍历"),p(t)])]),H,n("p",null,[s("题目："),n("a",J,[s("515. 在每个树行中找最大值"),p(t)])]),Q,n("p",null,[s("题目："),n("a",U,[s("116. 填充每个节点的下一个右侧节点指针"),p(t)])]),W,n("p",null,[s("题目："),n("a",X,[s("117. 填充每个节点的下一个右侧节点指针 II"),p(t)])]),Y,Z,$,nn,sn,n("p",null,[s("题目："),n("a",an,[s("104. 二叉树的最大深度"),p(t)])]),tn,n("p",null,[s("题目："),n("a",pn,[s("111. 二叉树的最小深度"),p(t)])]),en,n("p",null,[s("题目："),n("a",on,[s("226. 翻转二叉树"),p(t)])]),cn,n("p",null,[s("题目："),n("a",ln,[s("101. 对称二叉树"),p(t)])]),un,n("p",null,[s("题目："),n("a",rn,[s("100. 相同的树"),p(t)])]),kn,n("p",null,[s("题目："),n("a",dn,[s("572. 另一棵树的子树"),p(t)])]),vn,mn,bn,hn,yn,gn,fn,wn,_n,n("p",null,[s("题目："),n("a",xn,[s("559. N 叉树的最大深度"),p(t)])]),qn,Nn,On,Tn,Sn,n("p",null,[s("题目："),n("a",Ln,[s("222. 完全二叉树的节点个数"),p(t)])]),Mn,zn,Fn,Bn,Vn,Dn,An,jn,n("p",null,[s("题目："),n("a",Pn,[s("110. 平衡二叉树"),p(t)])]),Cn,En,In,n("p",null,[s("题目："),n("a",Rn,[s("257. 二叉树的所有路径"),p(t)])]),Kn,n("p",null,[s("题目："),n("a",Gn,[s("404. 左叶子之和"),p(t)])]),Hn,n("p",null,[s("题目："),n("a",Jn,[s("513. 找树左下角的值"),p(t)])]),Qn,n("p",null,[s("题目："),n("a",Un,[s("112. 路径总和"),p(t)])]),Wn,n("p",null,[s("题目："),n("a",Xn,[s("113. 路径总和 II"),p(t)])]),Yn,Zn,$n,ns,n("p",null,[s("题目："),n("a",ss,[s("106. 从中序与后序遍历序列构造二叉树"),p(t)])]),as,n("p",null,[s("题目："),n("a",ts,[s("105. 从前序与中序遍历序列构造二叉树"),p(t)])]),ps,n("p",null,[s("题目："),n("a",es,[s("654. 最大二叉树"),p(t)])]),os,cs,ls,is,n("p",null,[s("题目："),n("a",us,[s("617. 合并二叉树"),p(t)])]),rs,n("p",null,[s("题目："),n("a",ks,[s("236. 二叉树的最近公共祖先"),p(t)])]),ds,n("p",null,[s("递归思路参见这篇题解："),n("a",vs,[s("236. 二叉树的最近公共祖先 - 力扣（LeetCode）"),p(t)])]),ms,n("p",null,[s("题目链接："),n("a",bs,[s("700. 二叉搜索树中的搜索"),p(t)])]),hs,n("p",null,[s("题目："),n("a",ys,[s("98. 验证二叉搜索树"),p(t)])]),gs,n("p",null,[s("题目："),n("a",fs,[s("530. 二叉搜索树的最小绝对差"),p(t)])]),ws,_s,xs,n("p",null,[s("题目："),n("a",qs,[s("501. 二叉搜索树中的众数"),p(t)])]),Ns,n("p",null,[s("题目："),n("a",Os,[s("235. 二叉搜索树的最近公共祖先"),p(t)])]),Ts,n("p",null,[s("题目："),n("a",Ss,[s("701. 二叉搜索树中的插入操作"),p(t)])]),Ls,Ms])}const Ds=e(b,[["render",zs],["__file","binary_tree.html.vue"]]);export{Ds as default};
