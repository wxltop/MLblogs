import{_ as o,r as i,o as e,c as l,a as t,b as n,d as s,e as a}from"./app-aa9cafec.js";const d="/MLblogs/assets/2024-10-06-23-20-46-image-39e43154.png",g="/MLblogs/assets/2024-10-21-14-53-12-image-040fb7aa.png",h="/MLblogs/assets/2024-10-21-14-55-49-image-e4829131.png",p={},T={class:"custom-container info"},c=t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])],-1),P=t("p",{class:"custom-container-title"},"INFO",-1),u={href:"https://www.nowcoder.com/discuss/375434024733450240",target:"_blank",rel:"noopener noreferrer"},S={href:"https://blog.csdn.net/qq_40479372/article/details/132178043#:~:text=%E6%9C%80%E5%BC%BA%E5%A4%A7%E5%8E%82%E5%85%AB%E8%82%A1",target:"_blank",rel:"noopener noreferrer"},C=a('<h2 id="tcp-ip五层模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip五层模型" aria-hidden="true">#</a> TCP/IP五层模型</h2><ol><li><p>应用层：提供各种网络应用，比如HTTP（网页浏览）、FTP（文件传输）、SMTP（电子邮件）等。</p></li><li><p>传输层：定义传输协议，比如TCP（保证数据可靠传输）和UDP（不保证数据可靠传输）。TCP就像一个可靠的快递员，会保证你的信件完整无误地送到；UDP就像一个速度很快的快递员，但可能会丢包。</p></li><li><p>网络层：负责数据包在网络中的路由选择，将数据包从源主机传输到目的主机。IP协议是这一层的核心协议，它给每个数据包分配一个唯一的IP地址，就像每个人的身份证一样。</p></li><li><p>数据链路层：将数据组装成数据帧，并从一个节点传输到另一个相邻节点，负责数据的物理传输。</p></li><li><p>物理层：定义物理设备和传输介质，比如网线、光纤、无线电波等，负责数据的比特流传输。</p></li></ol><table><thead><tr><th></th><th>应用场景</th></tr></thead><tbody><tr><td>TCP</td><td>文件传输、电子邮件、远程登录、数据库访问、web浏览等</td></tr><tr><td>UDP</td><td>实时音视频传输（网络直播）、在线游戏、DNS域名解析等</td></tr></tbody></table><h2 id="http是什么-http-常见的状态码" tabindex="-1"><a class="header-anchor" href="#http是什么-http-常见的状态码" aria-hidden="true">#</a> HTTP是什么？ HTTP 常见的状态码？</h2><p>HTTP是超文本传输协议(HTTP 是在计算机世界的协议。它使计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。)</p><img src="'+d+'" title="" alt="" data-align="center"><table><thead><tr><th>状态码</th><th>显示</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr></tbody></table><h2 id="get-和-post-的区别" tabindex="-1"><a class="header-anchor" href="#get-和-post-的区别" aria-hidden="true">#</a> GET 和 POST 的区别？</h2><ul><li><p><strong>GET请求的安全性问题</strong></p><ul><li><strong>URL可见性:</strong> GET请求的参数会直接附加在URL后面，任何人都可以通过浏览器地址栏或网络抓包工具看到这些参数。</li><li><strong>容易被篡改:</strong> 攻击者可以修改URL中的参数，从而达到恶意目的，例如修改订单金额、绕过权限验证等。</li></ul></li><li><p><strong>POST请求的优势</strong></p><ul><li><strong>参数隐藏:</strong> POST请求的参数通常放在请求体中，不会直接暴露在URL中，增加了安全性。</li><li><strong>数据量更大:</strong> POST请求可以传输更大的数据量，而GET请求的URL长度有限制。</li></ul></li><li><p><strong>HTTPS的重要性</strong></p><ul><li><strong>加密传输:</strong> HTTPS使用SSL/TLS协议对数据进行加密，即使数据被截获，攻击者也无法读取其中的内容。</li><li><strong>身份验证:</strong> HTTPS可以验证服务器的身份，防止中间人攻击。</li></ul></li></ul><h2 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手" aria-hidden="true">#</a> 三次握手</h2><p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSED。</p><img title="" src="'+g+'" alt="" data-align="center" width="423"><ul><li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始<strong>序列号x</strong>，客户端向服务端发送的字段中包含<strong>标志位SYN=1</strong>，序列号seq=x。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN。</li><li>第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括<strong>标志位SYN=1，ACK=1</strong>，<strong>序列号seq=y</strong>，<strong>确认号ack=x+1</strong>。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中<strong>SYN=1表示要和客户端建立一个连接</strong>，<strong>ACK=1表示确认序号有效</strong>）</li><li>第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含<strong>标志位ACK=1，序列号seq=x+1，确认号ack=y+1</strong>。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。<strong>此时连接建立完成。</strong></li></ul><h2 id="两次握手可以嘛" tabindex="-1"><a class="header-anchor" href="#两次握手可以嘛" aria-hidden="true">#</a> 两次握手可以嘛？</h2><p>第三次握手主要为了<strong>防止已失效的连接请求报文段</strong>突然又传输到了服务端，导致产生问题。</p><ul><li>比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。</li><li>连接成功，等待数据传输完毕后，就释放了连接。</li><li>然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。</li><li>如果不采用三次握手，只要B发出确认，就建立新的连接了，<strong>此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。</strong></li></ul><h2 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a> 四次挥手</h2><img title="" src="'+h+'" alt="" data-align="center" width="405"><ul><li>A的应用进程先向其TCP发出<strong>连接释放报文段</strong>（FIN=1，seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。</li><li>B收到连接释放报文段后即<strong>发出确认报文段</strong>（ACK=1，ack=u+1，seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，<strong>A到B的连接释放</strong>。</li><li>A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</li><li>B发送完数据，就会<strong>发出连接释放报文段</strong>（FIN=1，ACK=1，seq=w，ack=u+1），B进入LAST-ACK（最后确认）状态，<strong>等待A的确认</strong>。</li><li>A收到B的连接释放报文段后，对此<strong>发出确认报文段</strong>（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。<strong>此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最大报文段生存时间）后，A才进入CLOSED状态</strong>。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。</li></ul><h2 id="tcp和udp的区别" tabindex="-1"><a class="header-anchor" href="#tcp和udp的区别" aria-hidden="true">#</a> TCP和UDP的区别</h2><ul><li>TCP<strong>面向连接</strong>；UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供<strong>可靠的服务</strong>；UDP不保证可靠交付。</li><li>TCP<strong>面向字节流</strong>，把数据看成一连串无结构的字节流；UDP是面向报文的。</li><li>TCP有<strong>拥塞控制</strong>；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</li><li>TCP连接是全双工的可靠信道，只能是点对点；而UDP可以一对一、一对多、多对一、多对多。</li><li>TCP首部开销20字节；UDP的首部8个字节。</li></ul><h2 id="tcp可靠的原因" tabindex="-1"><a class="header-anchor" href="#tcp可靠的原因" aria-hidden="true">#</a> TCP可靠的原因？</h2><ol><li><p>确认和重传机制</p></li><li><p>数据排序</p></li><li><p>流量控制：发送方维护一个滑动窗口，接收方维护一个接收窗口</p></li><li><p>拥塞控制：慢启动、拥塞避免、快速重传、快速恢复</p></li></ol><h2 id="https与http的区别" tabindex="-1"><a class="header-anchor" href="#https与http的区别" aria-hidden="true">#</a> HTTPS与HTTP的区别？</h2><ul><li>HTTP是超文本传输协议，信息是<strong>明文传输</strong>；HTTPS则是具有<strong>安全性</strong>的ssl加密传输协议。</li><li>HTTP和HTTPS用的端口不一样，HTTP端口是80，HTTPS是443。</li><li>HTTPS协议<strong>需要到CA机构申请证书</strong>，一般需要一定的费用。</li><li>HTTP运行在TCP协议之上；HTTPS运行在SSL协议之上，SSL运行在TCP协议之上。</li></ul><h2 id="dns-的解析过程" tabindex="-1"><a class="header-anchor" href="#dns-的解析过程" aria-hidden="true">#</a> DNS 的解析过程？</h2><ol><li>浏览器搜索<strong>自己的DNS缓存</strong></li><li>若没有，则搜索<strong>操作系统中的DNS缓存和hosts文件</strong></li><li>若没有，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向<strong>根域名服务器、顶级域名服务器、权限域名服务器</strong>发起查询请求，最终返回IP地址给本地域名服务器</li><li>本地域名服务器将得到的IP地址返回给<strong>操作系统</strong>，同时自己也<strong>将IP地址缓存起来</strong></li><li>操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来</li><li>浏览器得到域名对应的IP地址</li></ol><h2 id="浏览器中输入url返回页面过程" tabindex="-1"><a class="header-anchor" href="#浏览器中输入url返回页面过程" aria-hidden="true">#</a> 浏览器中输入URL返回页面过程？</h2><p>1、解析URL得到发送给web的信息，并生产 HTTP 请求信息</p><p>2、查询服务器域名对应的IP 地址，这个过程中涉及到DNS解析。</p><p>3、通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的<strong>协议栈</strong>。</p><p>4、经过TCP三次握手建立连接进行数据传输。</p><p>5、TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><p>6、生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC</strong> <strong>头部</strong>。</p><p>7、后续还会经过网卡、交换机和路由器到对端，然后就是一个反向的过程。</p>',35);function A(_,b){const r=i("ExternalLinkIcon");return e(),l("div",null,[t("div",T,[c,P,t("p",null,[t("a",u,[n("【计算机网络】2023校招计网八股汇总（附答案～）_牛客网"),s(r)])]),t("p",null,[t("a",S,[n("计算机网络八股文背诵版-CSDN博客"),s(r)])])]),C])}const I=o(p,[["render",A],["__file","network.html.vue"]]);export{I as default};
