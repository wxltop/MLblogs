import{_ as n,o as s,c as a,e as t}from"./app-aa9cafec.js";const e={},p=t(`<h2 id="python" tabindex="-1"><a class="header-anchor" href="#python" aria-hidden="true">#</a> python</h2><h3 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h3><p>通常使用双端队列deque（double-end queue），deque支持线程安全、有效内存地以近似O(1)的性能在deque的两端插入和删除元素，尽管list也支持相似的操作，但是它主要在固定长度操作上的优化，从而在pop(0)和insert(0,v)（会改变数据的位置和大小）上有O(n)的时间复杂度。导入包：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
q <span class="token operator">=</span> deque
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>q.append(e)</code>。右端添加元素</p></li><li><p><code>q.appendleft(e)</code>。左端添加元素</p></li><li><p><code>q.extend(e)</code>。从右端逐个添加可迭代对象，如列表、元组、字典、字符串等。</p></li><li><p><code>q.extendleft(e)</code>。往左端逐个添加可迭代对象</p></li><li><p><code>q.pop()</code>。将右端第一个元素弹出</p></li><li><p><code>q.popleft()</code>。将左端第一个元素弹出</p></li><li><p><code>q.count(e)</code>。统计元素e的个数</p></li><li><p><code>q.insert(index, obj)</code>。在指定位置插入元素</p></li><li><p><code>q.clear()</code>。删除全部元素</p></li><li><p><code>q.remove(e)</code>。移除第一次出现的元素e</p></li><li><p><code>deque(maxlen=n)</code>。最大长度为n，当限制长度的deque增加超过限制数的项时, 另一边的项会<code>自动删除</code>。</p></li><li><p><code>q.rotate(n)</code>。从右侧反转n步，如果n为负数，则从左侧反转。d.rotate(1) 等于 d.appendleft(d.pop())。如：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>st <span class="token operator">=</span> <span class="token string">&quot;abbcd&quot;</span>
dst <span class="token operator">=</span> deque<span class="token punctuation">(</span>st<span class="token punctuation">)</span>
dst<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;d&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="栈" tabindex="-1"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h3><p>栈也可以使用deque实现。</p><h3 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>a <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p><code>a.add(e)</code></p></li><li><p><code>a.remove(e)</code></p></li><li><p><code>a = a.union({e1, e2, ...})</code></p></li><li><p><code>a.pop()</code></p></li></ul><h3 id="单调栈" tabindex="-1"><a class="header-anchor" href="#单调栈" aria-hidden="true">#</a> 单调栈</h3><p>栈内元素是单调的。即压入一个数，若大于栈顶，则弹出栈顶。</p><h3 id="优先队列" tabindex="-1"><a class="header-anchor" href="#优先队列" aria-hidden="true">#</a> 优先队列</h3><p>一般使用堆来实现，堆的特性：</p><ol><li>堆一定是一个完全二叉树。完全二叉树：<strong>只允许最后一行没满</strong>，且<strong>最后一行必须从左往右排序（不能出现左边没有填满的情况，右边填满）</strong>，最后一行元素间不能有间隔。</li><li>堆序性。堆的每一个父节点数值&gt;子节点数值，则是大根堆；堆的每一个父节点数值&lt;子节点数值，则是小根堆。</li><li>将堆的各个顶点赋予序号，则可以用数组存储</li><li>上虑和下虑。指树的调整方向，是从下往上还是从上往下。两者的时间复杂度都为O(logN)，即和树高有关。</li><li>插入新元素。新元素一般插入堆的尾部即可。然后使用O(logN)的复杂度调整一下。</li></ol><p><strong>建堆方式：</strong></p><ol><li><p>自顶向下：从上往下构建堆，每次加入一个，都得将下面新加入的节点往上更新。<strong>时间复杂度为O(NlogN)</strong>，因为每加入一个节点需要O(logN)时间来调整。</p></li><li><p>自下向上：方法是先将乱序的堆构建好，然后从下往上排序。这种建堆的方法<strong>时间复杂度为O(N)。</strong></p></li></ol><p><strong>堆排序：</strong></p><p>将优先队列中的元素依次弹出即可。所以时间复杂度为O(NlogN)。</p><p>如果使用<strong>大根堆排序</strong>，即维护一个大根堆，每次从中拿出最大值。考虑到空间复杂度，不使用额外的空间，直接将最大值放在数组的末尾，将原来末尾的数放在树根。这样得到的就是一个<strong>从小到大的数组</strong>。</p><p>如果使用<strong>小根堆排序</strong>，最终得到一个从<strong>大到小的数组</strong>。</p><p><strong>python使用优先队列：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> heapq
<span class="token comment"># python 默认的优先队列是小根堆, 所以nums[i]前加负号</span>
q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">]</span>  
heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>q<span class="token punctuation">)</span>

<span class="token comment"># 加入元素</span>
heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 弹出元素</span>
heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="c" tabindex="-1"><a class="header-anchor" href="#c" aria-hidden="true">#</a> C++</h2><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p><p>其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。</p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p><hr><ol><li>C++中stack 是容器么？</li><li>我们使用的stack是属于哪个版本的STL？</li><li>我们使用的STL中stack是如何实现的？</li><li>stack 提供迭代器来遍历stack空间么？</li></ol><p>栈和队列是STL（C++标准库）里面的两个数据结构。C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。栈和队列是SGI STL里面的数据结构.</p><p>栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。<strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong> 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p><p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p><p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。<strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p>`,41),o=[p];function d(l,i){return s(),a("div",null,o)}const r=n(e,[["render",d],["__file","prior_skills.html.vue"]]);export{r as default};
