import{_ as r,r as a,o as t,c as n,a as i,b as o,d as s,e as l}from"./app-aa9cafec.js";const h={},d=i("div",{class:"custom-container info"},[i("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[i("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[i("circle",{cx:"12",cy:"12",r:"9"}),i("path",{d:"M12 8h.01"}),i("path",{d:"M11 12h1v4h1"})])]),i("p",{class:"custom-container-title"},"INFO"),i("p",null,"https://www.nowcoder.com/discuss/353159072050520064")],-1),c=l('<h2 id="用户态和内核态" tabindex="-1"><a class="header-anchor" href="#用户态和内核态" aria-hidden="true">#</a> 用户态和内核态</h2><ul><li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li><li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ul><h2 id="系统调用" tabindex="-1"><a class="header-anchor" href="#系统调用" aria-hidden="true">#</a> 系统调用</h2><ul><li>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</li><li>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</li></ul><p>系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h2 id="用户态切换至内核态" tabindex="-1"><a class="header-anchor" href="#用户态切换至内核态" aria-hidden="true">#</a> 用户态切换至内核态</h2><ul><li>系统调用<br> 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如 read 操作，比如前例中 fork() 实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</li><li>异常<br> 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如<strong>缺页异常</strong>。</li><li>外围设备的中断<br> 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。<strong>比如硬盘读写操作完成</strong>，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li></ul><p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p><h2 id="并行和并发" tabindex="-1"><a class="header-anchor" href="#并行和并发" aria-hidden="true">#</a> 并行和并发</h2><p>并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。<br> 并行：两个程序在某一时刻同时运行，强调同时发生。</p><h2 id="阻塞和非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞和非阻塞" aria-hidden="true">#</a> 阻塞和非阻塞</h2><p>阻塞是指调用线程或者进程被操作系统挂起。<br> 非阻塞是指调用线程或者进程不会被操作系统挂起。</p><h2 id="同步和异步" tabindex="-1"><a class="header-anchor" href="#同步和异步" aria-hidden="true">#</a> 同步和异步</h2><p>同步与异步同步是阻塞模式，异步是非阻塞模式。<br> 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去；<br> 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。</p><h2 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理" aria-hidden="true">#</a> 进程管理</h2><h3 id="进程、线程、协程的区别" tabindex="-1"><a class="header-anchor" href="#进程、线程、协程的区别" aria-hidden="true">#</a> 进程、线程、协程的区别</h3><ul><li>进程是<strong>资源分配的最基本的单位</strong>，运行一个程序会创建一个或多个进程，进程就是运行起来的可执行程序。</li><li>线程是<strong>程序执行的最基本的单位</strong>，是轻量级的进程，每个进程里都有一个主线程，且只能有一个，和进程是相互依存的关系，生命周期和进程一样。</li><li>协程是<strong>用户态的轻量级线程</strong>，是线程内部的基本单位。无需线程上下文切换的开销、无需原子操作锁定及同步的开销、方便切换控制流，简化编程模型。</li></ul><p>进程和线程的区别的话</p><ul><li>首先从资源来说，<strong>进程是资源分配的基本单位</strong>，但是线程不拥有资源，线程可以访问隶属进程的资源。</li><li>然后从调度来说，<strong>线程是独立调度的基本单位</strong>，在同一进程中线程切换的话不会引起进程的切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程的切换。</li><li>从系统开销来讲，由于创建或撤销进程，系统都要分配回收资源，所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换的时候，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境设置，而线程切换只需保存和设置少量寄存器的内容，开销很小。</li><li>通信方面来说，线程间可以通过直接读写同一进程的数据进行通信，但是进程通信需要借助一些复杂的方法。</li></ul><h3 id="pcb" tabindex="-1"><a class="header-anchor" href="#pcb" aria-hidden="true">#</a> PCB</h3><ul><li>PCB主要包含下面几部分的内容： <ul><li>进程的描述信息，比如进程的名称，标识符，</li><li>处理机的状态信息，当程序中断是保留此时的信息，以便 CPU 返回时能从断点执行</li><li>进程调度信息，比如阻塞原因，状态，优先级等等</li><li>进程控制和资源占用，同步通信机制，链接指针（指向队列中下一个进程的 PCB 地址）</li></ul></li><li>PCB 的作用 <ul><li>PCB是<strong>进程实体的一部分</strong>，是操作系统中最重要的数据结构</li><li>由于它的存在，使得多道程序环境下，不能独立运行的程序成为一个能独立运行的基本单位，使得程序可以并发执行</li><li>系统通过 PCB 来感知进程的存在。（换句话说，PCB 是进程存在的唯一标识）</li><li>进程的组成可以用下图来表示，PCB 就是他唯一标识符。<br><img src="https://uploadfiles.nowcoder.com/images/20211226/820488794_1640503265595/53A907732353F3A0169EF2122F347866" title="图片标题" alt="图片说明" data-align="center"></li></ul></li></ul><h3 id="进程创建和撤销的流程" tabindex="-1"><a class="header-anchor" href="#进程创建和撤销的流程" aria-hidden="true">#</a> 进程创建和撤销的流程</h3><p>在应用中创建一个子进程的过程如下：</p><ul><li>申请空白的PCB</li><li>初始化进程描述信息</li><li>为进程分配资源以及地址空间</li><li>将其插入就绪队列中</li></ul><p>撤销一个进程：</p><ul><li>查找需要撤销的进程的 PCB</li><li>如果进程处于运行状态，终止进程并进行调度</li><li>终止子孙进程 - 归还资源</li><li>将它从所在的队列中移除</li></ul><h3 id="进程状态" tabindex="-1"><a class="header-anchor" href="#进程状态" aria-hidden="true">#</a> 进程状态</h3><p>创建状态、就绪状态、运行状态、阻塞状态、结束状态。</p><ul><li>其中只有就绪状态和运行状态能互相转化，当进程为就绪态时，等待 CPU 分配时间片，得到时间片后就进入 运行状态</li><li>运行状态在使用完 CPU 时间片后，又重回就绪态。</li><li>阻塞状态是进程在运行状态时，需要等待某个资源比如打印机资源，而进入一个挂起的状态，等资源拿到后会回到就绪状态，等待 CPU 时间片。</li></ul><h3 id="进程调度算法" tabindex="-1"><a class="header-anchor" href="#进程调度算法" aria-hidden="true">#</a> 进程调度算法</h3>',31),p={href:"https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},u=l('<p><strong>先来先服务 first-come first-serverd（FCFS）</strong></p><p>非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>短作业优先 shortest job first（SJF）</strong></p><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong></p><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="进程之间的通信方法" tabindex="-1"><a class="header-anchor" href="#进程之间的通信方法" aria-hidden="true">#</a> 进程之间的通信方法</h3><p><strong>管道：</strong></p><ol><li><p>某一时间只能单向传输；各进程互斥地访问管道；数据以数据流的形式写入管道，当管道写满时，write()系统调用被阻塞，等待读进程将数据取走，当读进程把数据全部取走后，read()被阻塞</p></li><li><p>如果没写满就不允许读，如果没有读完就不允许写</p></li><li><p>数据一旦被读，就从管道中被抛弃，所以只能有一个读进程</p></li></ol><p><strong>消息队列：</strong></p><ol><li><p>消息队列的通信模式是这样的：a 进程要给 b 进程发消息，只需要把消息挂在消息队列（可以是中介邮局，也可以是进程自己的信箱）里就行了，b 进程需要的时候再去取消息队列里的消息。</p></li><li><p>消息队列可以独立于读写进程存在，就算进程终止时，消息队列的内容也不会被删除。</p></li><li><p>读进程可以根据消息类型有选择的接收消息，而不像 FIFO 那样只能默认接收。</p></li></ol><p><strong>共享内存</strong></p><ol><li><p>共享内存的方式就可以解决拷贝耗时很长的问题了。</p></li><li><p>共享内存是最快的一种进程通信的方式，因为进程是直接对内存进行存取的。因为可以多个进程对共享内存同时操作，所以对共享空间的访问必须要求进程对共享内存的访问是互斥的。所以我们经常把信号量和共享内存一起使用来实现进程通信。</p></li></ol><p><strong>信号量</strong></p><ul><li>共享内存最大的问题就是多进程竞争内存的问题，就像平时所说的线程安全的问题，那么就需要靠信号量来保证进程间的操作的同步与互斥。</li><li>信号量其实就是个计数器，例如信号量的初始值是 1，然后 a 进程访问临界资源的时候，把信号量设置为 0，然后进程 b 也要访问临界资源的时候，发现信号量是 0，就知道已有进程在访问临界资源了，这时进程 b 就访问不了了，所以说信号量也是进程间的一种通信方式。</li></ul><p><strong>套接字</strong> 套接字可以实现两个不同的机器之间的进程通信，比如 socket 使用。</p><h2 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h2><h3 id="死锁发生的条件" tabindex="-1"><a class="header-anchor" href="#死锁发生的条件" aria-hidden="true">#</a> 死锁发生的条件？</h3><ol><li>互斥条件：是资源分配是互斥的，资源要么处于被分配给一个进程的状态，要么就是可用状态。</li><li>等待和占有条件：进程在请求资源得不到满足的时候，进入阻塞等待状态，且不释放已占有的资源。</li><li>不剥夺条件：已经分配给一个进程的资源不能强制性地被抢占，只能等待占有他的进程释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程释放所占有的资源。</li></ol><h3 id="避免死锁的发生" tabindex="-1"><a class="header-anchor" href="#避免死锁的发生" aria-hidden="true">#</a> 避免死锁的发生？</h3><ul><li>预防策略：从形成死锁的条件入手，基本思想就是打破形成死锁的四个条件中的一个或多个，保证系统不会进入死锁状态。 <ul><li>破坏互斥条件：比如只读文件、磁盘等软硬件资源可采用这种办法处理。</li><li>破坏占有和等待条件：在进程开始执行之前，就把其要申请的所有资源全部分配给他，直到所有资源都满足，才开始执行。</li><li>破坏不剥夺条件：允许进程强行从资源占有者那里夺取某些资源</li><li>破坏环路等待条件：给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次执行。</li></ul></li><li>银行家算法：进程对某个资源提出请求时，判断该请求是否会使得系统进入不安全状态，如果是，则拒绝，否则接受分配</li></ul><h3 id="发生死锁怎么办" tabindex="-1"><a class="header-anchor" href="#发生死锁怎么办" aria-hidden="true">#</a> 发生死锁怎么办？</h3><ul><li>死锁检测：发生死锁之前总归需要先检测到死锁吧，不然怎么进行接下来的操作？可以通过检测有向图中是否存在环来检测，从一个节点出发进行 dfs，对访问过的节点进行标记，如果访问到了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li><li>死锁恢复： <ul><li>撤销进程法： <ul><li><ol><li>撤消陷于死锁的全部进程；</li></ol></li><li><ol start="2"><li>逐个撤消陷于死锁的进程，直到死锁不存在；</li></ol></li></ul></li></ul></li></ul>',23);function g(B,E){const e=a("ExternalLinkIcon");return t(),n("div",null,[d,c,i("p",null,[i("a",p,[o("计算机操作系统 - 进程管理 | CS-Notes 面试笔记"),s(e)])]),u])}const f=r(h,[["render",g],["__file","os.html.vue"]]);export{f as default};
