import{_ as s,r as l,o as i,c as o,a as n,b as e,d as r,e as t}from"./app-aa9cafec.js";const p="/MLblogs/assets/2024-10-03-21-59-35-image-75a36200.png",c="/MLblogs/assets/2024-10-03-22-11-04-image-77e8278a.png",d="/MLblogs/assets/2024-10-03-23-08-04-image-eb06f27d.png",g="/MLblogs/assets/2024-10-03-23-09-23-image-107b1023.png",u="/MLblogs/assets/2024-10-03-23-13-12-image-d7de5e8e.png",h="/MLblogs/assets/2024-10-05-10-45-19-image-1161e8b4.png",m="/MLblogs/assets/2024-10-05-10-48-04-image-70b8c1c5.png",b="/MLblogs/assets/2024-10-05-10-51-58-image-6dd81aa4.png",v="/MLblogs/assets/2024-10-04-21-59-10-image-a7f27005.png",k="/MLblogs/assets/2024-10-03-22-08-32-image-01deb12f.png",_={},f=t('<h2 id="对比c-c-java-python" tabindex="-1"><a class="header-anchor" href="#对比c-c-java-python" aria-hidden="true">#</a> 对比C，C++，JAVA，python</h2><p>C语言：</p><ul><li><p><strong>执行效率高：</strong> C语言是编译型语言，直接生成机器码，执行速度快。</p></li><li><p>可以直接操作硬件，对内存的控制非常灵活，适合开发操作系统、嵌入式系统等对性能要求高的应用。</p></li><li><p>缺点：需要手动管理内存，容易出错。指针的使用容易导致内存泄漏等问题。<strong>可移植性较差：</strong> 不同平台的C编译器可能存在差异，需要进行移植。</p></li><li><p>适用场景：操作系统内核，嵌入式系统，高性能计算，底层库的开发</p></li></ul><p>C++：</p><ul><li><p>兼具C语言的高效和面向对象的特性</p></li><li><p>STL提供了丰富的容器、算法和数据结构</p></li><li><p>缺点：学习困难，开发难度大</p></li><li><p>适用场景：游戏开发，大型软件开发，服务器端开发</p></li></ul><p>java：</p><ul><li><p>纯粹的面向对象语言</p></li><li><p><strong>平台无关性：</strong> 编译成字节码，可以在任何支持Java虚拟机的平台上运行</p></li><li><p><strong>安全性高：</strong> 自动垃圾回收，避免了内存泄漏的问题</p></li><li><p><strong>丰富的类库：</strong> JDK提供了丰富的类库</p></li><li><p>缺点：</p><ul><li><strong>占用内存较大：</strong> JVM运行时需要占用较多的内存。</li></ul></li></ul><p>python：</p><ul><li><p>简单，开发效率高，丰富的第三方库，实现方便，接近自然语言，可读性强</p></li><li><p>缺点：</p><ul><li><p><strong>执行效率较低：</strong> 动态语言，解释执行，效率不如编译型语言。</p></li><li><p><strong>线程性能较差：</strong> GIL的存在限制了Python的多线程性能。</p></li></ul></li><li><p>适用场景：机器学习，科学计算，脚本开发，web开发等</p></li></ul><h2 id="面向对象-vs-面向过程" tabindex="-1"><a class="header-anchor" href="#面向对象-vs-面向过程" aria-hidden="true">#</a> 面向对象 vs 面向过程</h2><ul><li><strong>面向过程：</strong> 强调的是功能和过程，将程序看作<strong>一系列的步骤</strong>，按照顺序执行。C语言是典型的面向过程语言。</li><li><strong>面向对象：</strong> 强调的是对象和类，<strong>将程序看作一系列相互作用的对象</strong>。Java、C++是面向对象语言。</li></ul><p>比如思考一个简单的程序，每一步该如何做，如何按步骤实现，这就是面向过程思想。面向过程适合<strong>不需要协作的任务</strong>，一般需要多人协作完成的任务，宏观上使用面向对象来把控，微观上使用面向过程来实现。</p><h2 id="c-c-运行步骤" tabindex="-1"><a class="header-anchor" href="#c-c-运行步骤" aria-hidden="true">#</a> C/C++运行步骤</h2>',13),y={href:"https://zhuanlan.zhihu.com/p/618037867",target:"_blank",rel:"noopener noreferrer"},C=t('<p>编写完成一个C/C++程序后，想要运行起来，必须要经过四个步骤：<strong>预处理、编译、汇编和链接</strong>。每个步骤都会生成对应的文件。</p><img src="'+p+'" title="" alt="" data-align="center"><ul><li><p>预处理：编译前的一些准备工作。预编译把一些#define的宏定义完成文本替换，然后将#include的文件里的内容复制到.cpp文件里，如果.h文件里还有.h文件，就递归展开。</p></li><li><p>编译：将我们写的代码转为汇编代码，它的工作是检查词法和语法规则，所以，如果程序没有词法或则语法错误，那么不管逻辑是怎样错误的，都不会报错。</p></li><li><p>汇编：汇编过程将上一步的汇编代码(main.s)转换成机器码(machine code)，这一步产生的文件叫做目标文件(main.o)，是二进制格式。汇编这一步需要为每一个源文件（.cpp）产生一个目标文件（.o）。</p></li><li><p>链接：编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。链接（Link）其实就是一个“打包”的过程，它将所有二进制形式的目标文件(.o)和系统组件组合成一个可执行文件。</p></li></ul><h2 id="python运行步骤" tabindex="-1"><a class="header-anchor" href="#python运行步骤" aria-hidden="true">#</a> python运行步骤</h2><p>Python是一种解释型语言，它的代码不是直接编译成机器码执行的，而是通过解释器逐行读取并执行。</p><ul><li><strong>源代码读取：</strong> 解释器从源文件或命令行中读取Python代码。</li><li><strong>词法分析：</strong> 将源代码分解成一个个单词（token），如关键字、标识符、运算符等。</li><li><strong>语法分析：</strong> 根据Python语法规则，将单词组装成语法树，检查代码的语法是否正确。</li><li><strong>语义分析：</strong> 检查语法树的含义，确保代码的逻辑是正确的。</li><li><strong>代码生成：</strong> 将语法树转换为字节码（bytecode），这是Python的一种中间表示形式。</li><li><strong>字节码执行：</strong> Python虚拟机（PVM）逐条执行字节码指令。</li></ul><img title="" src="'+c+'" alt="" width="372" data-align="center"><p>影响Python执行效率的因素：</p><ul><li><strong>动态类型：</strong> Python变量的类型在运行时确定，增加了解释器的负担。</li><li><strong>动态内存分配：</strong> Python的内存管理由垃圾回收机制负责，在频繁的内存分配和回收过程中会产生开销。</li><li><strong>字节码执行：</strong> 字节码的执行需要经过虚拟机的解释，相比直接执行机器码会有一定的性能损耗。</li></ul><p>优化Python代码的建议：</p><ul><li><strong>使用内置函数和模块：</strong> Python的标准库提供了很多高效的函数和模块，可以减少代码量并提高性能。</li><li><strong>合理使用数据结构：</strong> 选择合适的数据结构可以显著提高算法的效率。</li><li><strong>避免不必要的循环：</strong> 尽量使用列表推导式、生成器表达式等来代替循环。</li><li><strong>使用Cython：</strong> Cython可以将Python代码编译成C扩展，提高执行效率。</li><li><strong>利用多进程或多线程：</strong> 对于I/O密集型任务，可以利用多进程或多线程来提高并发性。</li></ul><h2 id="java运行步骤" tabindex="-1"><a class="header-anchor" href="#java运行步骤" aria-hidden="true">#</a> Java运行步骤</h2><p>将编写好的java源文件：编译成字节码文件-&gt;传给JRE，JRE内的JVM会执行该字节码文件</p><img title="" src="'+d+'" alt="" data-align="center" width="360"><p>JDK，JRE，JVM的关联：</p><p>JRE包含：jvm，库函数，运行java应用程序所必须的文件</p><p>JDK包含：JRE，编译器，调试器等</p><img title="" src="'+g+'" alt="" data-align="center" width="276"><p>正是JVM的存在，java有了跨平台的特性，一次编译（得到字节码文件），随处运行（不同平台有各自的JVM）</p><img src="'+u+'" title="" alt="" data-align="center"><h2 id="c和java中的数据类型" tabindex="-1"><a class="header-anchor" href="#c和java中的数据类型" aria-hidden="true">#</a> C和java中的数据类型</h2><p>C中：</p><table><thead><tr><th>bool</th><th>1字节</th></tr></thead><tbody><tr><td>char</td><td>1字节</td></tr><tr><td>short</td><td>2字节</td></tr><tr><td>int</td><td>4字节</td></tr><tr><td>float</td><td>4字节</td></tr><tr><td>long</td><td>4字节</td></tr><tr><td>double</td><td>8字节</td></tr><tr><td>long long</td><td>8字节</td></tr></tbody></table><p>注意这都是有符号数，比如int，表示的最大数为2^(32 - 1)，多出来的1位是符号数。为何bool要用一个字节来存储？而不是1 bit？因为计算机内无法寻址只有1 bit的内容，只能寻址字节。</p><p>java vs c</p><ul><li><p><strong>C语言的char类型</strong>：通常占一个字节，用于表示ASCII字符。</p></li><li><p><strong>Java语言的char类型</strong>：占两个字节，用于表示Unicode字符，可以表示更多的字符。</p></li><li><p><strong>Java中的布尔型</strong>：理论上占一位，但实际占用可能因JVM实现而异，通常为一个字节。</p></li><li><p><strong>C语言中的布尔型</strong>：通常占一个字节，为了兼容性和硬件优化。</p></li></ul><p>java中，基本数据类型分为：</p><ul><li><p>数值型。整数类型（byte：1字节, short：2字节, int：4字节, long：8字节），浮点类型（float：4字节, double：8字节）</p></li><li><p>字符型。2个字节</p></li><li><p>布尔型。1位</p></li></ul><p>能表示的数值范围：</p><img src="'+h+'" title="" alt="" data-align="center"><p>java中的进制：</p><img src="'+m+'" title="" alt="" data-align="center"><p>例如：</p><img src="'+b+`" title="" alt="" data-align="center"><h2 id="浮点数陷阱" tabindex="-1"><a class="header-anchor" href="#浮点数陷阱" aria-hidden="true">#</a> 浮点数陷阱</h2><p>下面这段代码输出结果是true：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">float</span> d1 <span class="token operator">=</span> <span class="token number">34434322f</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> d2 <span class="token operator">=</span> d1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d1 <span class="token operator">==</span> d2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个问题涉及到浮点数在计算机中的表示和运算的本质。</p><ul><li><strong>有限精度：</strong> 计算机无法精确表示所有的实数，浮点数只能用有限的位数来近似表示一个实数。</li><li><strong>舍入误差：</strong> 在浮点数运算过程中，由于精度限制，会产生舍入误差。</li></ul><p>其实如果将d1输出，结果将是：<code>3.443432E7</code>，所以：</p><ul><li><p><strong>浮点数的表示范围和精度：</strong></p><ul><li><code>float</code>类型虽然表示范围比<code>int</code>大，但<strong>精度有限</strong>。当数值较大时，<strong>用科学技术法表示一个浮点数</strong>，相邻的两个<code>float</code>数之间的差值可能大于1。</li><li>在你的例子中，<code>34434322</code>这个数已经比较大了。当加上1时，由于<code>float</code>类型的精度限制，可能无法精确表示<code>34434323</code>这个值。</li><li>计算机可能将<code>d1 + 1</code>的结果四舍五入或截断，使其与<code>d1</code>的值非常接近，以至于在比较时被认为是相等的。</li></ul></li><li><p><strong>浮点数比较的陷阱：</strong></p><ul><li><strong>直接比较浮点数是否相等：</strong> 由于浮点数的精度问题，直接使用<code>==</code>运算符比较两个浮点数是否相等，往往是不准确的。</li><li><strong>建议：</strong> 对于浮点数的比较，通常使用一个较小的误差范围来判断两个浮点数是否相等。</li></ul></li></ul><h2 id="两个浮点数相加" tabindex="-1"><a class="header-anchor" href="#两个浮点数相加" aria-hidden="true">#</a> 两个浮点数相加</h2><p>浮点数在计算机中采用科学计数法表示，由符号位、指数和尾数三部分组成。相加过程主要分为以下几个步骤：</p><ol><li>对阶</li></ol><ul><li><strong>目的：</strong> 使两个浮点数的指数相同，以便进行尾数相加。</li><li><strong>方法：</strong> 将指数较小的浮点数的尾数右移，同时指数加1，直到两个数的指数相等。右移过程中可能丢失精度。</li></ul><ol start="2"><li>尾数相加</li></ol><ul><li><strong>直接相加：</strong> 将对阶后的两个浮点数的尾数直接相加。</li><li><strong>溢出处理：</strong> 如果相加结果的尾数大于1，则需要右移一位，指数加1。</li><li><strong>规格化：</strong> 将结果调整为规格化形式，即尾数的最高位为1。</li></ul><ol start="3"><li>舍入</li></ol><ul><li><strong>舍入：</strong> 如果尾数的位数超过了规定的精度，需要进行舍入。常见的舍入方式有向零舍入、向上舍入、向下舍入和舍入到最近。</li></ul><ol start="4"><li>规格化</li></ol><ul><li><strong>调整指数和尾数：</strong> 将结果调整为规格化形式，即尾数的最高位为1。</li></ul><p>例如：</p><p>假设有两个浮点数：</p><ul><li>A = 1.101 * 2^3</li><li>B = 0.110 * 2^2</li></ul><p>相加过程如下：</p><ol><li><strong>对阶：</strong> 将B的尾数右移一位，指数加1，得到B = 0.011 * 2^3。</li><li><strong>尾数相加：</strong> A + B = 1.101 * 2^3 + 0.011 * 2^3 = 1.120 * 2^3。</li><li><strong>舍入：</strong> 如果尾数的位数超过了规定的精度，进行舍入。</li><li><strong>规格化：</strong> 如果结果不是规格化形式，进行规格化。</li></ol><h2 id="短路与、短路或" tabindex="-1"><a class="header-anchor" href="#短路与、短路或" aria-hidden="true">#</a> 短路与、短路或</h2><p><code>&amp;&amp;</code>，<code>||</code>分别表示短路与和短路或，比如有很长的判断语句，如果使用<code>&amp;&amp;</code>，第一个为False，则不用往后看了，而<code>&amp;</code>是普通的与，不会短路，第一个为False会继续往后看。</p><h2 id="指针和引用的区别" tabindex="-1"><a class="header-anchor" href="#指针和引用的区别" aria-hidden="true">#</a> 指针和引用的区别</h2><ul><li><p>指针是一个存储内存地址的变量，指针可以设置为空指针；引用只能引用已经存在的变量，引用本身不是新的变量，他们不占用内存，没有真正的存储空间。</p></li><li><p>引用能做的事情，指针也能做，但是指针看起来相对复杂，引用更为简洁。</p></li><li><p>引用一旦创建了，不能改变，而指针可以改变，如果尝试给它赋值，其实是将其所引用的变量的值改变了。</p></li><li><p>引用不能用声明式的定义（如char&amp; a;），而要具体引用(char&amp; a=b)。</p></li></ul><h2 id="new和malloc的区别" tabindex="-1"><a class="header-anchor" href="#new和malloc的区别" aria-hidden="true">#</a> new和malloc的区别</h2><p>功能上的区别</p><ul><li><p><strong>new运算符：</strong></p><ul><li><strong>分配内存并调用构造函数：</strong> new不仅分配内存，而且会自动调用对象的构造函数，对对象进行初始化。</li><li><strong>返回指定类型的指针：</strong> new返回的是一个指向新分配对象的指针，类型与对象类型一致，无需强制类型转换。</li><li><strong>与类类型绑定：</strong> new与C++的面向对象特性紧密结合，用于创建对象。</li></ul></li><li><p><strong>malloc函数：</strong></p><ul><li><strong>仅分配原始内存：</strong> malloc只分配一块原始的内存空间，不进行任何初始化。</li><li><strong>返回void指针：</strong> malloc返回一个void指针，需要进行强制类型转换。</li><li><strong>与C语言兼容：</strong> malloc是C语言的标准库函数，用于通用内存分配。</li></ul></li></ul><p>使用场景：</p><ul><li><p><strong>new：</strong></p><ul><li>创建对象：new是C++中创建对象的标准方式。</li><li>使用自定义的内存分配器：通过重载operator new，可以实现自定义的内存分配策略。</li></ul></li><li><p><strong>malloc：</strong></p><ul><li>分配原始内存：当需要分配一块原始的内存空间时，可以使用malloc。</li><li>C语言代码：在C语言代码中，只能使用malloc来分配内存。</li></ul></li></ul><img src="`+v+`" title="" alt="" data-align="center"><p>代码示例：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="类和结构体的区别" tabindex="-1"><a class="header-anchor" href="#类和结构体的区别" aria-hidden="true">#</a> 类和结构体的区别</h2><p>类完全可以替代结构体，C++中留有结构体是为了兼容C，防止突然一个关键字消失导致很多代码不能用，其次结构体里的变量默认是public，而类内默认是private。</p><h2 id="static关键字" tabindex="-1"><a class="header-anchor" href="#static关键字" aria-hidden="true">#</a> static关键字</h2><img title="" src="`+k+'" alt="" width="288" data-align="center">',72);function w(x,J){const a=l("ExternalLinkIcon");return i(),o("div",null,[f,n("p",null,[n("a",y,[e("详解C/C++代码的预处理、编译、汇编、链接全过程 - 知乎 (zhihu.com)"),r(a)])]),C])}const M=s(_,[["render",w],["__file","compare.html.vue"]]);export{M as default};
