import{_ as e,r as l,o,c,a as n,b as s,d as p,e as a}from"./app-aa9cafec.js";const i="/MLblogs/assets/2024-02-20-11-02-46-image-787fe0b9.png",u="/MLblogs/assets/2024-03-13-10-42-55-image-47760843.png",r="/MLblogs/assets/2024-02-04-17-52-46-image-3407c50d.png",m="/MLblogs/assets/2024-02-06-13-50-12-image-85e8e2e6.png",d="/MLblogs/assets/2024-02-22-20-45-49-image-26fe9263.png",k="/MLblogs/assets/2024-02-22-20-46-11-image-f8a3bb75.png",h="/MLblogs/assets/2024-02-22-20-48-43-image-0ea4c8e3.png",v="/MLblogs/assets/2024-02-15-15-49-26-image-ba02ee99.png",g="/MLblogs/assets/2024-02-15-15-50-11-image-e39bf7bf.png",b="/MLblogs/assets/2024-02-15-13-36-10-image-f6e0f50d.png",y={},w={class:"custom-container info"},x=n("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[n("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[n("circle",{cx:"12",cy:"12",r:"9"}),n("path",{d:"M12 8h.01"}),n("path",{d:"M11 12h1v4h1"})])],-1),f=n("p",{class:"custom-container-title"},"INFO",-1),_=n("p",null,"《数据结构与算法之美》王争",-1),M={href:"https://blog.csdn.net/MoreWindows/category_859207.html",target:"_blank",rel:"noopener noreferrer"},O=a('<img src="'+i+'" title="" alt="" data-align="center"><h2 id="如何分析效率" tabindex="-1"><a class="header-anchor" href="#如何分析效率" aria-hidden="true">#</a> 如何分析效率</h2><p>在分析排序算法的时间复杂度时，要分别给出<strong>最好情况、最坏情况、平均情况</strong>下的时间复杂度。除此之外，还要说出最好、最坏时间复杂度对应的要排序的<strong>原始数据</strong>是什么样的。</p><p>在对<strong>同一阶时间复杂度</strong>的排序算法性能对比的时候，我们就<strong>要把系数、常数、低阶也考虑进来</strong>。</p><p><strong>原地排序</strong>（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p><p><strong>稳定性</strong>。如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间<strong>原有的先后顺序不变</strong>。</p><h2 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a> 冒泡排序</h2><p>稳定排序，原地排序</p>',8),j=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("，最好的情况下，如果加了flag，时间复杂度就为O(n)，即数据本身是有序的。平均时间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("。")],-1),L=n("p",null,[s("空间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])])],-1),N=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        flag <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                flag <span class="token operator">=</span> <span class="token boolean">True</span>
                data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> flag<span class="token punctuation">:</span>
            <span class="token keyword">return</span> data
    <span class="token keyword">return</span> data
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h2><p>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</p><p>稳定排序，原地排序</p>`,4),z=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("，时间复杂度就为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("，即数据本身是有序的。平均时间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("。")],-1),q=a(`<p>空间复杂度：O(1)</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        target <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        pos <span class="token operator">=</span> i
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> target <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                pos <span class="token operator">=</span> j
            <span class="token keyword">else</span><span class="token punctuation">:</span> 
                <span class="token keyword">break</span>
        data<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> target
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然插入排序和冒泡排序的时间复杂度一样，但是插入排序的赋值次数少于冒泡排序，所以实际使用上，插入排序花时间更短。</p><h2 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序" aria-hidden="true">#</a> 希尔排序</h2><p><strong>希尔排序是插入排序的改进版本</strong>。将原始列表<strong>分成多个子列表来排序</strong>，每个子列表使用插入排序来排序，而且这些子列表在整个排序过程中逐渐变得越来越小，直到最后成为一个列表。</p><p>具体来说，该算法的步骤是：</p><ol><li>初始化一个间隔（gap），通常是列表长度的一半，用来将列表分割成子列表。</li><li>对每个子列表进行插入排序。</li><li>缩小间隔（gap）。</li><li>重复步骤 2 和步骤 3，直到间隔（gap）变为 1，即完成排序。</li></ol>`,7),C={href:"https://zhuanlan.zhihu.com/p/34914588",target:"_blank",rel:"noopener noreferrer"},B=a('<img src="'+u+`" title="" alt="" data-align="center"><p>希尔排序的主要思想是通过<strong>大幅减少元素的移动次数</strong>来提高插入排序的性能。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    gap <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
    <span class="token keyword">while</span> gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>gap<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            temp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            j <span class="token operator">=</span> i
            <span class="token keyword">while</span> j <span class="token operator">&gt;=</span> gap <span class="token keyword">and</span> data<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">:</span>
                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span>
                j <span class="token operator">-=</span> gap
            data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp
        gap <span class="token operator">//=</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h2><p>选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><img title="" src="`+r+'" alt="" data-align="center" width="244">',6),G=n("p",null,[s("注意实现上的区别，如果真的按照上面对选择排序描述的方式来实现，那么实现一个数的时间复杂度就为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("。所以换一种实现的思路，即按照上面图示中的方式来实现，那么时间复杂度就为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("。")],-1),S=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        pos <span class="token operator">=</span> <span class="token number">0</span>
        min_val <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;inf&#39;</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min_val<span class="token punctuation">:</span>
                min_val <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                pos <span class="token operator">=</span> j
        data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不稳定排序，原地排序</p>`,2),V=n("p",null,[s("时间复杂度：最好、最坏、平均都是"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("。")],-1),A=a(`<p>空间复杂度：O(1)</p><p>为什么说是不稳定排序？比如：</p><p>9(1), 9(2), 1, 10</p><p>第一次排序的时候，需要将1插入位置0，就变成了：1, 9(2), 9(1), 10</p><h2 id="快排" tabindex="-1"><a class="header-anchor" href="#快排" aria-hidden="true">#</a> 快排</h2><p>有两种实现方式，第一种用列表推导式获得左右列表，但是空间复杂度为O(n)：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums
    p <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">]</span>
    left <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> nums <span class="token keyword">if</span> x <span class="token operator">&lt;</span> p<span class="token punctuation">]</span>
    middle <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> nums <span class="token keyword">if</span> x <span class="token operator">==</span> p<span class="token punctuation">]</span>
    right <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> nums <span class="token keyword">if</span> x <span class="token operator">&gt;</span> p<span class="token punctuation">]</span>
    <span class="token keyword">return</span> sort<span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> middle <span class="token operator">+</span> sort<span class="token punctuation">(</span>right<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用双指针、空间复杂度为O(1)的方式实现。</p>`,8),D=n("p",null,[s("时间复杂度为：大部分情况下都是"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(nlogn)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("。极端情况下，比如数组已经有序了，每次选择pivot会将序列划分为两个长度悬殊非常大的序列，这种情况的时间复杂度就非常高，退化为了"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("。")],-1),E=n("p",null,[s("空间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logn)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])],-1),F=a(`<p><strong>不稳定</strong>的排序算法</p><p><strong>原地</strong>排序算法</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    将数组划分为两部分并将基准元素放在正确的位置上的函数。

    参数:
    arr (list): 待划分的输入列表。
    low (int): 要划分的子数组的起始索引。
    high (int): 要划分的子数组的结束索引。

    返回:
    int: 划分后基准元素的索引。
    &quot;&quot;&quot;</span>
    <span class="token keyword">import</span> random
    rand_index <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
    arr<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span>

    pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span>  <span class="token comment"># 选择基准元素（这里选择最后一个元素）</span>
    i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment"># 较小元素的索引</span>

    <span class="token comment"># 遍历子数组</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token comment"># 交换 arr[i] 和 arr[j]</span>
            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

    <span class="token comment"># 将基准元素放在正确的位置上（arr[i+1]是比pivot大的数）</span>
    <span class="token comment"># 将其放在末尾无影响</span>
    arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 返回基准元素的索引</span>

<span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    用快速排序算法递归地对数组进行排序的函数。

    参数:
    arr (list): 待排序的输入列表。
    low (int): 要排序的子数组的起始索引。
    high (int): 要排序的子数组的结束索引。
    &quot;&quot;&quot;</span>
    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> high<span class="token punctuation">:</span>
        <span class="token comment"># pi 是划分索引，arr[pi] 现在在正确的位置上</span>
        pi <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>

        <span class="token comment"># 递归地对划分前和划分后的元素进行排序</span>
        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的partition函数实现的是将pi位置的元素固定下来，其左边都是比其小的值，右边是比其大的值。</p><p>这个函数里面的循环遍历子列表的所有数值，i表示的是比pivot小的数的边界，j表示比pivot大的数的边界。如果一开始遍历的数都是比pivot小，则i和j一直相等。若有一段数值都是比pivot大，此时是这样的状态：</p><img src="`+m+'" title="" alt="" data-align="center"><p>下一个状态，j指向0，比4小，则应该由i维护，i交换nums[i+1]和4。当遍历结束后，还需要将pivot放在正确的位置。</p>',7),I=n("p",null,[s("快排的时间复杂度很受pivot值的大小的影响，"),n("strong",null,"极端情况下"),s("，若每次刚好pivot都是子列表的最大值（即序列已经是有序的），那么每次都会完整遍历一次子列表，"),n("strong",null,[s("时间复杂度就降为了"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("msup",null,[n("mi",null,"n"),n("mn",null,"2")]),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},[n("span",{class:"mord mathnormal"},"n"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.8141em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},"2")])])])])])])]),n("span",{class:"mclose"},")")])])]),s("。")])],-1),T=n("h3",{id:"双路快排和三路快排",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#双路快排和三路快排","aria-hidden":"true"},"#"),s(" 双路快排和三路快排")],-1),W=n("p",null,"上述例子中提到，当数据是倒序的，快排的时间复杂度很高，所以使用随机抽取pivot，但是还有一种情况，数据很多重复的元素，这样随机抽取的很可能还是那个数，导致复杂度仍然很高。在标准的快速排序算法中，枢纽元素的选择可能会导致将序列分成两部分，其中一部分非常小而另一部分非常大，这样会导致递归树变得不平衡，使得算法的时间复杂度退化到O(n^2)。而二路快速排序算法通过在分区过程中将相同的元素分到同一侧，可以在很大程度上避免这种情况的发生，使得递归树更加平衡。",-1),P={href:"https://blog.csdn.net/qq_43479736/article/details/105416945",target:"_blank",rel:"noopener noreferrer"},U=a(`<p><strong>先看二路快排</strong>：</p><p>二路快速排序算法能够克服序列中有大量重复元素的问题，这是因为在分区过程中，相同的元素会被分到同一侧，从而减少了后续的比较和交换次数。</p><p>下面代码的实现中，和普通快排的区别就只在于partition函数。可以比较一下发现，<strong>二路快排减少了很多交换的步骤</strong>。</p><p>注意到下面增加i和j的循环中，是保证严格大于或者小于的，为何不能大于等于或者小于等于呢？如果遇到相等的情况，这时候while循环就会退出，即交换i和j的值，使得对于包含大量相同元素的数组， 双方相等的数据就会交换，这样就可以一定程度<strong>保证两路的数据量平衡</strong>，当然如果<strong>希望arr[i]和arr[j]相等时不进行无意义的交换</strong>，可以加一个判断语句。这样加了判断语句其实和三路快排的核心思想（不交换相等元素）相似。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> random
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
        nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>a<span class="token punctuation">]</span>

    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;二路快排&quot;&quot;&quot;</span>
        <span class="token comment"># 随机取一个数</span>
        randindex <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
        <span class="token comment"># 将随机选取的数和arr[low]交换一下</span>
        <span class="token comment"># 这样可以避免由于原始数组本来是逆序的，导致快排效率降低</span>
        self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> randindex<span class="token punctuation">,</span> low<span class="token punctuation">)</span>
        <span class="token comment"># 取arr[low]作为pivot，这个数就是刚刚随机选取的数</span>
        pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span>

        <span class="token comment"># 注意i 和j的起始值</span>
        i <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token number">1</span>
        j <span class="token operator">=</span> high
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token comment"># 一定可以跳出循环</span>
            <span class="token comment"># 一直增加i，直到arr[i]不能严格 &lt; pivot</span>
            <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> high <span class="token keyword">and</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token comment"># 一直增加j, 直到arr[j] 不能严格 &gt; pivot</span>
            <span class="token keyword">while</span> j <span class="token operator">&gt;=</span> low <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">:</span>
                j <span class="token operator">-=</span> <span class="token number">1</span>
            <span class="token comment"># 若已经违背了i和j的关系，结束循环</span>
            <span class="token keyword">if</span> i <span class="token operator">&gt;=</span> j<span class="token punctuation">:</span> <span class="token keyword">break</span>
            <span class="token comment"># 若未违背i和j的关系，交换二者对应的值</span>
            self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
            <span class="token comment"># 记得更新 i 和 j</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
            j <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token comment"># 最后需要将 pivot 放到正确的位置上</span>
        <span class="token comment"># 此时j指向的元素是数组中最后一个小于v的元素, </span>
        <span class="token comment"># i指向的元素是数组中第一个大于v的元素</span>
        self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
        <span class="token keyword">return</span> j


    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 这部分和普通快排一样</span>
        <span class="token keyword">if</span> low <span class="token operator">&lt;</span> high<span class="token punctuation">:</span>
            pivot <span class="token operator">=</span> self<span class="token punctuation">.</span>partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> nums
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>三路快排</strong>：</p><p>三路快速排序相比双路快速排序的优势在于：减少了对重复元素的比较操作，因为重复元素在一次排序中就已经作为单独一部分排好了，之后只需要对不等于该重复元素的其他元素进行排序。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="归并" tabindex="-1"><a class="header-anchor" href="#归并" aria-hidden="true">#</a> 归并</h2><p>稳定性：主要看实现的merge函数，可以尽量实现成一个稳定的算法。</p>`,10),H=n("p",null,[s("时间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(nlogn)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("（最好、最坏、平均）")],-1),J=n("p",null,[s("空间复杂度："),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])]),s("。尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。")],-1),K=a(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> data

    <span class="token comment"># 分割数据列表为两个子列表</span>
    middle <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
    left_half <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span>middle<span class="token punctuation">]</span>
    right_half <span class="token operator">=</span> data<span class="token punctuation">[</span>middle<span class="token punctuation">:</span><span class="token punctuation">]</span>

    <span class="token comment"># 递归地对子列表进行归并排序</span>
    left_half <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>left_half<span class="token punctuation">)</span>
    right_half <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>right_half<span class="token punctuation">)</span>

    <span class="token comment"># 合并排序后的子列表</span>
    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>left_half<span class="token punctuation">,</span> right_half<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
    merged <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    left_index<span class="token punctuation">,</span> right_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>

    <span class="token comment"># 将左右两个子列表中的元素按顺序合并</span>
    <span class="token keyword">while</span> left_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> right_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> left<span class="token punctuation">[</span>left_index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span>right_index<span class="token punctuation">]</span><span class="token punctuation">:</span>
            merged<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>left_index<span class="token punctuation">]</span><span class="token punctuation">)</span>
            left_index <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            merged<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>right_index<span class="token punctuation">]</span><span class="token punctuation">)</span>
            right_index <span class="token operator">+=</span> <span class="token number">1</span>

    <span class="token comment"># 将剩余的元素添加到已合并的列表中</span>
    merged <span class="token operator">+=</span> left<span class="token punctuation">[</span>left_index<span class="token punctuation">:</span><span class="token punctuation">]</span>
    merged <span class="token operator">+=</span> right<span class="token punctuation">[</span>right_index<span class="token punctuation">:</span><span class="token punctuation">]</span>

    <span class="token keyword">return</span> merged
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="桶排序" tabindex="-1"><a class="header-anchor" href="#桶排序" aria-hidden="true">#</a> 桶排序</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment">#桶排序（适用于数据分布均匀的排序）</span>
<span class="token keyword">def</span> <span class="token function">bucketsort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    maxv<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    minv<span class="token operator">=</span><span class="token builtin">min</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    bucket<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    bucketCount<span class="token operator">=</span><span class="token number">3</span>
    perbucket<span class="token operator">=</span><span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token operator">+</span>bucketCount<span class="token punctuation">)</span><span class="token operator">//</span>bucketCount
    <span class="token keyword">for</span> num <span class="token keyword">in</span> s<span class="token punctuation">:</span>
        bucketidx<span class="token operator">=</span><span class="token punctuation">(</span>num<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">//</span>perbucket
        bucket<span class="token punctuation">[</span>bucketidx<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>bucketCount<span class="token punctuation">)</span><span class="token punctuation">:</span>
        selectsort<span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    idx<span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>bucketCount<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>j
            idx<span class="token operator">+=</span><span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="计数排序" tabindex="-1"><a class="header-anchor" href="#计数排序" aria-hidden="true">#</a> 计数排序</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment">#计数排序(适用于数据范围小的排序，空间换时间)</span>
<span class="token keyword">def</span> <span class="token function">countsort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    cnt<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
    counter<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>cnt
    <span class="token keyword">for</span> x <span class="token keyword">in</span> s<span class="token punctuation">:</span>
        counter<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
    s<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        s<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="基数排序" tabindex="-1"><a class="header-anchor" href="#基数排序" aria-hidden="true">#</a> 基数排序</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment">#基数排序</span>
<span class="token keyword">def</span> <span class="token function">radixsort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    base<span class="token operator">=</span><span class="token number">1</span>
    maxv<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token keyword">while</span> base<span class="token operator">&lt;=</span>maxv<span class="token punctuation">:</span>
        bucket<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            bucket<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> num <span class="token keyword">in</span> s<span class="token punctuation">:</span>
            idx<span class="token operator">=</span>num<span class="token operator">//</span>base<span class="token operator">%</span><span class="token number">10</span>
            bucket<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>
        l<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> v <span class="token keyword">in</span> bucket<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">:</span>
                s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">=</span>v
                l<span class="token operator">+=</span><span class="token number">1</span>
        base<span class="token operator">*=</span><span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h2>`,8),Q={href:"https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.337.search-card.all.click&vd_source=29624dbb703a504c9a36c90ccf9558d4",target:"_blank",rel:"noopener noreferrer"},R=n("p",null,"堆的特性：",-1),X=n("ol",null,[n("li",null,[n("p",null,[s("堆一定是一个完全二叉树。完全二叉树："),n("strong",null,"只允许最后一行没满"),s("，且"),n("strong",null,"最后一行必须从左往右排序（不能出现左边没有填满的情况，右边填满）"),s("，最后一行元素间不能有间隔。")]),n("img",{src:d,title:"",alt:"","data-align":"center"}),n("img",{src:k,title:"",alt:"","data-align":"center"})]),n("li",null,[n("p",null,"堆序性。堆的每一个父节点数值>子节点数值，则是大根堆；堆的每一个父节点数值<子节点数值，则是小根堆。")]),n("li",null,[n("p",null,"将堆的各个顶点这样赋予序号，则可以用数组存储："),n("img",{src:h,title:"",alt:"","data-align":"center"})]),n("li",null,[n("p",null,[s("上虑和下虑。指树的调整方向，是从下往上还是从上往下。两者的时间复杂度都为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"N"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logN)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},")")])])]),s("，即和树高有关。")])]),n("li",null,[n("p",null,[s("插入新元素。新元素一般插入堆的尾部即可。然后使用"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"N"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logN)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},")")])])]),s("的复杂度调整一下。")])])],-1),Y=n("p",null,[n("strong",null,"建堆方式"),s("：")],-1),Z=n("p",null,[s("自顶向下：从上往下构建堆，每次加入一个，都得将下面新加入的节点往上更新。"),n("strong",null,[s("时间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"N"),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"N"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(NlogN)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"Nl"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},")")])])])]),s("，因为每加入一个节点需要"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"N"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logN)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},")")])])]),s("时间来调整。")],-1),$=n("p",null,[s("自下向上：方法是先将乱序的堆构建好，然后从下往上排序。这种建堆的方法"),n("strong",null,[s("时间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"N"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(N)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},")")])])]),s("。")])],-1),nn=n("p",null,[n("strong",null,"优先队列"),s("：弹出最小/最大元素")],-1),sn=n("p",null,[s("弹出堆顶元素，然后将最后一个元素放入堆顶，执行一遍调整，所以弹出一个元素的时间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"N"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(logN)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},")")])])]),s("。")],-1),an=n("p",null,[n("strong",null,"堆排序"),s("：")],-1),tn=n("p",null,[s("将优先队列中的元素依次弹出即可。所以时间复杂度为"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"N"),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mi",null,"N"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(NlogN)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"Nl"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},")")])])]),s("。")],-1),pn=a(`<p>如果使用<strong>大根堆排序</strong>，即维护一个大根堆，每次从中拿出最大值。考虑到空间复杂度，不使用额外的空间，直接将最大值放在数组的末尾，将原来末尾的数放在树根。这样得到的就是一个<strong>从小到大的数组</strong>。</p><p>如果使用<strong>小根堆排序</strong>，最终得到一个从<strong>大到小的数组</strong>。</p><p><strong>堆排序代码：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">maxheapify</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>
    son<span class="token operator">=</span>start<span class="token operator">*</span><span class="token number">2</span>
    <span class="token keyword">while</span> son<span class="token operator">&lt;=</span>end<span class="token punctuation">:</span>
        <span class="token keyword">if</span> son<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;=</span>end <span class="token keyword">and</span> heap<span class="token punctuation">[</span>son<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>heap<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token punctuation">:</span>
            son<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">if</span> heap<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token operator">&gt;</span>heap<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span>
            heap<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span>hap<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token operator">=</span>heap<span class="token punctuation">[</span>son<span class="token punctuation">]</span><span class="token punctuation">,</span>heap<span class="token punctuation">[</span>start<span class="token punctuation">]</span>
            start<span class="token punctuation">,</span>son<span class="token operator">=</span>son<span class="token punctuation">,</span>son<span class="token operator">*</span><span class="token number">2</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
<span class="token keyword">def</span> <span class="token function">heapsort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    heap<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">+</span>a
    root<span class="token operator">=</span><span class="token number">1</span>
    l<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        maxheapify<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>i<span class="token punctuation">,</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>heap<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>heap<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">,</span>heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        maxheapify<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>root<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> heap<span class="token punctuation">[</span>root<span class="token punctuation">:</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="外部排序" tabindex="-1"><a class="header-anchor" href="#外部排序" aria-hidden="true">#</a> 外部排序</h2>`,5),en={href:"https://blog.csdn.net/ailunlee/article/details/84548950",target:"_blank",rel:"noopener noreferrer"},ln=a('<p>给你一个包含20亿个int类型整数的文件，计算机的内存只有2GB，怎么给它们排序？一个int数占4个字节，20个亿需要80亿字节，大概占用8GB的内存，而计算机只有2GB的内存，数据都装不下！可以把8GB分割成4个2GB的数据来排，然后在把他们拼凑回去。</p><p>排序的时候可以选择<strong>快速排序</strong>或<strong>归并排序</strong>等算法。为了方便，我们把排序好的2G有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。</p><p><strong>注意</strong>读取的时候是每次读取一个int数，通过比较之后再输出。按照这个方法来回合并。现在假设一个情景：<strong>需要排序的int数有12个，内存一次只能装下3个int数。</strong></p><img title="" src="'+v+'" alt="" data-align="center" width="391"><p>接下来把12个数据分成4份，然后排序成有序子串，<strong>这个过程每一个数读写一次</strong>：</p><img src="'+g+'" title="" alt="" data-align="center"><p>然后把子串进行两两合并，每一个数再读一次，写一次：</p><p><img title="" src="'+b+'" alt="" data-align="center" width="411">重复直到合并成一个包含6个int有序子串， 再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串。<strong>这整个过程中，每一个数都被读写3次</strong>。</p><p><strong>优化策略：</strong></p><p>硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读写多次，很耗时。</p><p>在进行有序子串合并的时候，不采取两两合并的方法，而是可以3个子串，或4个子串一起来合并。即<strong>多路归并</strong>，4个有序子串的合并，叫4路归并。如果是n个有序子串的合并，就把它称为n路归并。n并非越大越好。</p><p>在上述例子中，直接使用3路归并，每个数的读写次数还是3，似乎没什么提升，但如果<strong>假设需要排序的数有9个，那么经过第一次排序之后得到3个有序子串</strong>，然后使用<strong>3路归并</strong>，最终<strong>每一个数只用读写两次即可</strong>。</p><p><strong>置换选择：</strong></p><p><strong>想办法减少有序子串的总个数，能减少数据从硬盘读写的次数。</strong> 前面简单归并生成4个有序子串，使用置换选择可以有效减少子串的总数。</p><p><strong>还是以前面的12个数为例，内存最多放3个整数</strong>。</p><p>思路是这样：从12个数据读取3个存到内存中，然后从内存中选出最小的那个数放进子串p1里；之后再从剩余的9个数据读取一个放到内存中，然后再从内存中选出一个数放进子串p1里，直到内存里的最小数比p1的最新的数小，则p1结束，开始p2。当然还可以先暂时将小的数放在一边，直到将所有的数据都过一遍，使得p1尽可能长。</p><p>为了<strong>防止每次读入一个新的数都要排序</strong>，可以<strong>维护一个小根堆</strong>。</p><p>按照置换选择的思路，可以将上例12个数据分为两个有序子串，最好的情况下，所有数据只生成一个有序子串；最坏的情况下，和原来没采取置换选择算法一样，还是4个子串，那平均性能如何呢？</p><p>结论：如果内存可以容纳n个元素的话，那么平均每个子串的长度为2m，也就是说，使用置换选择算法我们可以减少一半的子串数。</p>',19);function on(cn,un){const t=l("ExternalLinkIcon");return o(),c("div",null,[n("div",w,[x,f,_,n("p",null,[n("a",M,[s("白话经典算法系列_MoreWindows的博客-CSDN博客"),p(t)])])]),O,j,L,N,z,q,n("p",null,[s("下图来自"),n("a",C,[s("希尔排序就这么简单 - 知乎 (zhihu.com)"),p(t)])]),B,G,S,V,A,D,E,F,I,T,W,n("p",null,[s("解决上述问题的方式就是三路快排和双路快排。"),n("a",P,[s("图解快速排序及双路三路快速排序_快速排序和三路快速排序-CSDN博客"),p(t)])]),U,H,J,K,n("p",null,[n("a",Q,[s("【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆_哔哩哔哩_bilibili"),p(t)])]),R,X,Y,Z,$,nn,sn,an,tn,pn,n("p",null,[n("a",en,[s("外部排序_外排序-CSDN博客"),p(t)])]),ln])}const mn=e(y,[["render",on],["__file","paixu.html.vue"]]);export{mn as default};
